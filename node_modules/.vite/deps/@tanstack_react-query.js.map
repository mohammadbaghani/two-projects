{
  "version": 3,
  "sources": ["../../use-sync-external-store/cjs/use-sync-external-store-shim.development.js", "../../use-sync-external-store/shim/index.js", "../../@tanstack/query-core/build/esm/index.js", "../../@tanstack/react-query/src/QueryClientProvider.tsx", "../../@tanstack/react-query/src/isRestoring.tsx", "../../@tanstack/react-query/src/useQueries.ts", "../../@tanstack/react-query/src/QueryErrorResetBoundary.tsx", "../../@tanstack/react-query/src/utils.ts", "../../@tanstack/react-query/src/useBaseQuery.ts", "../../@tanstack/react-query/src/useQuery.ts", "../../@tanstack/react-query/src/Hydrate.tsx", "../../@tanstack/react-query/src/useIsFetching.ts", "../../@tanstack/react-query/src/useIsMutating.ts", "../../@tanstack/react-query/src/useMutation.ts", "../../@tanstack/react-query/src/useInfiniteQuery.ts"],
  "sourcesContent": ["/**\n * @license React\n * use-sync-external-store-shim.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n\n          'use strict';\n\n/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n}\n          var React = require('react');\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x, y) {\n  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n  ;\n}\n\nvar objectIs = typeof Object.is === 'function' ? Object.is : is;\n\n// dispatch for CommonJS interop named imports.\n\nvar useState = React.useState,\n    useEffect = React.useEffect,\n    useLayoutEffect = React.useLayoutEffect,\n    useDebugValue = React.useDebugValue;\nvar didWarnOld18Alpha = false;\nvar didWarnUncachedGetSnapshot = false; // Disclaimer: This shim breaks many of the rules of React, and only works\n// because of a very particular set of implementation details and assumptions\n// -- change any one of them and it will break. The most important assumption\n// is that updates are always synchronous, because concurrent rendering is\n// only available in versions of React that also have a built-in\n// useSyncExternalStore API. And we only use this shim when the built-in API\n// does not exist.\n//\n// Do not assume that the clever hacks used by this hook also work in general.\n// The point of this shim is to replace the need for hacks by other libraries.\n\nfunction useSyncExternalStore(subscribe, getSnapshot, // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n// React do not expose a way to check if we're hydrating. So users of the shim\n// will need to track that themselves and return the correct value\n// from `getSnapshot`.\ngetServerSnapshot) {\n  {\n    if (!didWarnOld18Alpha) {\n      if (React.startTransition !== undefined) {\n        didWarnOld18Alpha = true;\n\n        error('You are using an outdated, pre-release alpha of React 18 that ' + 'does not support useSyncExternalStore. The ' + 'use-sync-external-store shim will not work correctly. Upgrade ' + 'to a newer pre-release.');\n      }\n    }\n  } // Read the current snapshot from the store on every render. Again, this\n  // breaks the rules of React, and only works here because of specific\n  // implementation details, most importantly that updates are\n  // always synchronous.\n\n\n  var value = getSnapshot();\n\n  {\n    if (!didWarnUncachedGetSnapshot) {\n      var cachedValue = getSnapshot();\n\n      if (!objectIs(value, cachedValue)) {\n        error('The result of getSnapshot should be cached to avoid an infinite loop');\n\n        didWarnUncachedGetSnapshot = true;\n      }\n    }\n  } // Because updates are synchronous, we don't queue them. Instead we force a\n  // re-render whenever the subscribed state changes by updating an some\n  // arbitrary useState hook. Then, during render, we call getSnapshot to read\n  // the current value.\n  //\n  // Because we don't actually use the state returned by the useState hook, we\n  // can save a bit of memory by storing other stuff in that slot.\n  //\n  // To implement the early bailout, we need to track some things on a mutable\n  // object. Usually, we would put that in a useRef hook, but we can stash it in\n  // our useState hook instead.\n  //\n  // To force a re-render, we call forceUpdate({inst}). That works because the\n  // new object always fails an equality check.\n\n\n  var _useState = useState({\n    inst: {\n      value: value,\n      getSnapshot: getSnapshot\n    }\n  }),\n      inst = _useState[0].inst,\n      forceUpdate = _useState[1]; // Track the latest getSnapshot function with a ref. This needs to be updated\n  // in the layout phase so we can access it during the tearing check that\n  // happens on subscribe.\n\n\n  useLayoutEffect(function () {\n    inst.value = value;\n    inst.getSnapshot = getSnapshot; // Whenever getSnapshot or subscribe changes, we need to check in the\n    // commit phase if there was an interleaved mutation. In concurrent mode\n    // this can happen all the time, but even in synchronous mode, an earlier\n    // effect may have mutated the store.\n\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceUpdate({\n        inst: inst\n      });\n    }\n  }, [subscribe, value, getSnapshot]);\n  useEffect(function () {\n    // Check for changes right before subscribing. Subsequent changes will be\n    // detected in the subscription handler.\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceUpdate({\n        inst: inst\n      });\n    }\n\n    var handleStoreChange = function () {\n      // TODO: Because there is no cross-renderer API for batching updates, it's\n      // up to the consumer of this library to wrap their subscription event\n      // with unstable_batchedUpdates. Should we try to detect when this isn't\n      // the case and print a warning in development?\n      // The store changed. Check if the snapshot changed since the last time we\n      // read from the store.\n      if (checkIfSnapshotChanged(inst)) {\n        // Force a re-render.\n        forceUpdate({\n          inst: inst\n        });\n      }\n    }; // Subscribe to the store and return a clean-up function.\n\n\n    return subscribe(handleStoreChange);\n  }, [subscribe]);\n  useDebugValue(value);\n  return value;\n}\n\nfunction checkIfSnapshotChanged(inst) {\n  var latestGetSnapshot = inst.getSnapshot;\n  var prevValue = inst.value;\n\n  try {\n    var nextValue = latestGetSnapshot();\n    return !objectIs(prevValue, nextValue);\n  } catch (error) {\n    return true;\n  }\n}\n\nfunction useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {\n  // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n  // React do not expose a way to check if we're hydrating. So users of the shim\n  // will need to track that themselves and return the correct value\n  // from `getSnapshot`.\n  return getSnapshot();\n}\n\nvar canUseDOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');\n\nvar isServerEnvironment = !canUseDOM;\n\nvar shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;\nvar useSyncExternalStore$2 = React.useSyncExternalStore !== undefined ? React.useSyncExternalStore : shim;\n\nexports.useSyncExternalStore = useSyncExternalStore$2;\n          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n}\n        \n  })();\n}\n", "'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim.production.min.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim.development.js');\n}\n", "/**\n * query-core\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nclass Subscribable {\n  constructor() {\n    this.listeners = [];\n    this.subscribe = this.subscribe.bind(this);\n  }\n\n  subscribe(listener) {\n    this.listeners.push(listener);\n    this.onSubscribe();\n    return () => {\n      this.listeners = this.listeners.filter(x => x !== listener);\n      this.onUnsubscribe();\n    };\n  }\n\n  hasListeners() {\n    return this.listeners.length > 0;\n  }\n\n  onSubscribe() {// Do nothing\n  }\n\n  onUnsubscribe() {// Do nothing\n  }\n\n}\n\n// TYPES\n// UTILS\nconst isServer = typeof window === 'undefined';\nfunction noop() {\n  return undefined;\n}\nfunction functionalUpdate(updater, input) {\n  return typeof updater === 'function' ? updater(input) : updater;\n}\nfunction isValidTimeout(value) {\n  return typeof value === 'number' && value >= 0 && value !== Infinity;\n}\nfunction difference(array1, array2) {\n  return array1.filter(x => array2.indexOf(x) === -1);\n}\nfunction replaceAt(array, index, value) {\n  const copy = array.slice(0);\n  copy[index] = value;\n  return copy;\n}\nfunction timeUntilStale(updatedAt, staleTime) {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);\n}\nfunction parseQueryArgs(arg1, arg2, arg3) {\n  if (!isQueryKey(arg1)) {\n    return arg1;\n  }\n\n  if (typeof arg2 === 'function') {\n    return { ...arg3,\n      queryKey: arg1,\n      queryFn: arg2\n    };\n  }\n\n  return { ...arg2,\n    queryKey: arg1\n  };\n}\nfunction parseMutationArgs(arg1, arg2, arg3) {\n  if (isQueryKey(arg1)) {\n    if (typeof arg2 === 'function') {\n      return { ...arg3,\n        mutationKey: arg1,\n        mutationFn: arg2\n      };\n    }\n\n    return { ...arg2,\n      mutationKey: arg1\n    };\n  }\n\n  if (typeof arg1 === 'function') {\n    return { ...arg2,\n      mutationFn: arg1\n    };\n  }\n\n  return { ...arg1\n  };\n}\nfunction parseFilterArgs(arg1, arg2, arg3) {\n  return isQueryKey(arg1) ? [{ ...arg2,\n    queryKey: arg1\n  }, arg3] : [arg1 || {}, arg2];\n}\nfunction parseMutationFilterArgs(arg1, arg2, arg3) {\n  return isQueryKey(arg1) ? [{ ...arg2,\n    mutationKey: arg1\n  }, arg3] : [arg1 || {}, arg2];\n}\nfunction matchQuery(filters, query) {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale\n  } = filters;\n\n  if (isQueryKey(queryKey)) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false;\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false;\n    }\n  }\n\n  if (type !== 'all') {\n    const isActive = query.isActive();\n\n    if (type === 'active' && !isActive) {\n      return false;\n    }\n\n    if (type === 'inactive' && isActive) {\n      return false;\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false;\n  }\n\n  if (typeof fetchStatus !== 'undefined' && fetchStatus !== query.state.fetchStatus) {\n    return false;\n  }\n\n  if (predicate && !predicate(query)) {\n    return false;\n  }\n\n  return true;\n}\nfunction matchMutation(filters, mutation) {\n  const {\n    exact,\n    fetching,\n    predicate,\n    mutationKey\n  } = filters;\n\n  if (isQueryKey(mutationKey)) {\n    if (!mutation.options.mutationKey) {\n      return false;\n    }\n\n    if (exact) {\n      if (hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)) {\n        return false;\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false;\n    }\n  }\n\n  if (typeof fetching === 'boolean' && mutation.state.status === 'loading' !== fetching) {\n    return false;\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false;\n  }\n\n  return true;\n}\nfunction hashQueryKeyByOptions(queryKey, options) {\n  const hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashQueryKey;\n  return hashFn(queryKey);\n}\n/**\n * Default query keys hash function.\n * Hashes the value into a stable hash.\n */\n\nfunction hashQueryKey(queryKey) {\n  return JSON.stringify(queryKey, (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {\n    result[key] = val[key];\n    return result;\n  }, {}) : val);\n}\n/**\n * Checks if key `b` partially matches with key `a`.\n */\n\nfunction partialMatchKey(a, b) {\n  return partialDeepEqual(a, b);\n}\n/**\n * Checks if `b` partially matches with `a`.\n */\n\nfunction partialDeepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some(key => !partialDeepEqual(a[key], b[key]));\n  }\n\n  return false;\n}\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\n\nfunction replaceEqualDeep(a, b) {\n  if (a === b) {\n    return a;\n  }\n\n  const array = isPlainArray(a) && isPlainArray(b);\n\n  if (array || isPlainObject(a) && isPlainObject(b)) {\n    const aSize = array ? a.length : Object.keys(a).length;\n    const bItems = array ? b : Object.keys(b);\n    const bSize = bItems.length;\n    const copy = array ? [] : {};\n    let equalItems = 0;\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i];\n      copy[key] = replaceEqualDeep(a[key], b[key]);\n\n      if (copy[key] === a[key]) {\n        equalItems++;\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy;\n  }\n\n  return b;\n}\n/**\n * Shallow compare objects. Only works with objects that always have the same properties.\n */\n\nfunction shallowEqualObjects(a, b) {\n  if (a && !b || b && !a) {\n    return false;\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\nfunction isPlainArray(value) {\n  return Array.isArray(value) && value.length === Object.keys(value).length;\n} // Copied from: https://github.com/jonschlinkert/is-plain-object\n\nfunction isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  } // If has modified constructor\n\n\n  const ctor = o.constructor;\n\n  if (typeof ctor === 'undefined') {\n    return true;\n  } // If has modified prototype\n\n\n  const prot = ctor.prototype;\n\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  } // If constructor does not have an Object-specific method\n\n\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false;\n  } // Most likely a plain Object\n\n\n  return true;\n}\n\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\n\nfunction isQueryKey(value) {\n  return Array.isArray(value);\n}\nfunction isError(value) {\n  return value instanceof Error;\n}\nfunction sleep(timeout) {\n  return new Promise(resolve => {\n    setTimeout(resolve, timeout);\n  });\n}\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\n\nfunction scheduleMicrotask(callback) {\n  sleep(0).then(callback);\n}\nfunction getAbortController() {\n  if (typeof AbortController === 'function') {\n    return new AbortController();\n  }\n}\nfunction replaceData(prevData, data, options) {\n  // Use prev data if an isDataEqual function is defined and returns `true`\n  if (options.isDataEqual != null && options.isDataEqual(prevData, data)) {\n    return prevData;\n  } else if (options.structuralSharing !== false) {\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data);\n  }\n\n  return data;\n}\n\nclass FocusManager extends Subscribable {\n  constructor() {\n    super();\n\n    this.setup = onFocus => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onFocus(); // Listen to visibillitychange and focus\n\n\n        window.addEventListener('visibilitychange', listener, false);\n        window.addEventListener('focus', listener, false);\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('visibilitychange', listener);\n          window.removeEventListener('focus', listener);\n        };\n      }\n    };\n  }\n\n  onSubscribe() {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup);\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      var _this$cleanup;\n\n      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);\n      this.cleanup = undefined;\n    }\n  }\n\n  setEventListener(setup) {\n    var _this$cleanup2;\n\n    this.setup = setup;\n    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);\n    this.cleanup = setup(focused => {\n      if (typeof focused === 'boolean') {\n        this.setFocused(focused);\n      } else {\n        this.onFocus();\n      }\n    });\n  }\n\n  setFocused(focused) {\n    this.focused = focused;\n\n    if (focused) {\n      this.onFocus();\n    }\n  }\n\n  onFocus() {\n    this.listeners.forEach(listener => {\n      listener();\n    });\n  }\n\n  isFocused() {\n    if (typeof this.focused === 'boolean') {\n      return this.focused;\n    } // document global can be unavailable in react native\n\n\n    if (typeof document === 'undefined') {\n      return true;\n    }\n\n    return [undefined, 'visible', 'prerender'].includes(document.visibilityState);\n  }\n\n}\nconst focusManager = new FocusManager();\n\nclass OnlineManager extends Subscribable {\n  constructor() {\n    super();\n\n    this.setup = onOnline => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onOnline(); // Listen to online\n\n\n        window.addEventListener('online', listener, false);\n        window.addEventListener('offline', listener, false);\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('online', listener);\n          window.removeEventListener('offline', listener);\n        };\n      }\n    };\n  }\n\n  onSubscribe() {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup);\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      var _this$cleanup;\n\n      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);\n      this.cleanup = undefined;\n    }\n  }\n\n  setEventListener(setup) {\n    var _this$cleanup2;\n\n    this.setup = setup;\n    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);\n    this.cleanup = setup(online => {\n      if (typeof online === 'boolean') {\n        this.setOnline(online);\n      } else {\n        this.onOnline();\n      }\n    });\n  }\n\n  setOnline(online) {\n    this.online = online;\n\n    if (online) {\n      this.onOnline();\n    }\n  }\n\n  onOnline() {\n    this.listeners.forEach(listener => {\n      listener();\n    });\n  }\n\n  isOnline() {\n    if (typeof this.online === 'boolean') {\n      return this.online;\n    }\n\n    if (typeof navigator === 'undefined' || typeof navigator.onLine === 'undefined') {\n      return true;\n    }\n\n    return navigator.onLine;\n  }\n\n}\nconst onlineManager = new OnlineManager();\n\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1000 * 2 ** failureCount, 30000);\n}\n\nfunction canFetch(networkMode) {\n  return (networkMode != null ? networkMode : 'online') === 'online' ? onlineManager.isOnline() : true;\n}\nclass CancelledError {\n  constructor(options) {\n    this.revert = options == null ? void 0 : options.revert;\n    this.silent = options == null ? void 0 : options.silent;\n  }\n\n}\nfunction isCancelledError(value) {\n  return value instanceof CancelledError;\n}\nfunction createRetryer(config) {\n  let isRetryCancelled = false;\n  let failureCount = 0;\n  let isResolved = false;\n  let continueFn;\n  let promiseResolve;\n  let promiseReject;\n  const promise = new Promise((outerResolve, outerReject) => {\n    promiseResolve = outerResolve;\n    promiseReject = outerReject;\n  });\n\n  const cancel = cancelOptions => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions));\n      config.abort == null ? void 0 : config.abort();\n    }\n  };\n\n  const cancelRetry = () => {\n    isRetryCancelled = true;\n  };\n\n  const continueRetry = () => {\n    isRetryCancelled = false;\n  };\n\n  const shouldPause = () => !focusManager.isFocused() || config.networkMode !== 'always' && !onlineManager.isOnline();\n\n  const resolve = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onSuccess == null ? void 0 : config.onSuccess(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseResolve(value);\n    }\n  };\n\n  const reject = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onError == null ? void 0 : config.onError(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseReject(value);\n    }\n  };\n\n  const pause = () => {\n    return new Promise(continueResolve => {\n      continueFn = value => {\n        if (isResolved || !shouldPause()) {\n          return continueResolve(value);\n        }\n      };\n\n      config.onPause == null ? void 0 : config.onPause();\n    }).then(() => {\n      continueFn = undefined;\n\n      if (!isResolved) {\n        config.onContinue == null ? void 0 : config.onContinue();\n      }\n    });\n  }; // Create loop function\n\n\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return;\n    }\n\n    let promiseOrValue; // Execute query\n\n    try {\n      promiseOrValue = config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    }\n\n    Promise.resolve(promiseOrValue).then(resolve).catch(error => {\n      var _config$retry, _config$retryDelay;\n\n      // Stop if the fetch is already resolved\n      if (isResolved) {\n        return;\n      } // Do we need to retry the request?\n\n\n      const retry = (_config$retry = config.retry) != null ? _config$retry : 3;\n      const retryDelay = (_config$retryDelay = config.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;\n      const delay = typeof retryDelay === 'function' ? retryDelay(failureCount, error) : retryDelay;\n      const shouldRetry = retry === true || typeof retry === 'number' && failureCount < retry || typeof retry === 'function' && retry(failureCount, error);\n\n      if (isRetryCancelled || !shouldRetry) {\n        // We are done if the query does not need to be retried\n        reject(error);\n        return;\n      }\n\n      failureCount++; // Notify on fail\n\n      config.onFail == null ? void 0 : config.onFail(failureCount, error); // Delay\n\n      sleep(delay) // Pause if the document is not visible or when the device is offline\n      .then(() => {\n        if (shouldPause()) {\n          return pause();\n        }\n      }).then(() => {\n        if (isRetryCancelled) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  }; // Start loop\n\n\n  if (canFetch(config.networkMode)) {\n    run();\n  } else {\n    pause().then(run);\n  }\n\n  return {\n    promise,\n    cancel,\n    continue: () => {\n      continueFn == null ? void 0 : continueFn();\n    },\n    cancelRetry,\n    continueRetry\n  };\n}\n\nconst defaultLogger = console;\n\nfunction createNotifyManager() {\n  let queue = [];\n  let transactions = 0;\n\n  let notifyFn = callback => {\n    callback();\n  };\n\n  let batchNotifyFn = callback => {\n    callback();\n  };\n\n  const batch = callback => {\n    let result;\n    transactions++;\n\n    try {\n      result = callback();\n    } finally {\n      transactions--;\n\n      if (!transactions) {\n        flush();\n      }\n    }\n\n    return result;\n  };\n\n  const schedule = callback => {\n    if (transactions) {\n      queue.push(callback);\n    } else {\n      scheduleMicrotask(() => {\n        notifyFn(callback);\n      });\n    }\n  };\n  /**\n   * All calls to the wrapped function will be batched.\n   */\n\n\n  const batchCalls = callback => {\n    return (...args) => {\n      schedule(() => {\n        callback(...args);\n      });\n    };\n  };\n\n  const flush = () => {\n    const originalQueue = queue;\n    queue = [];\n\n    if (originalQueue.length) {\n      scheduleMicrotask(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach(callback => {\n            notifyFn(callback);\n          });\n        });\n      });\n    }\n  };\n  /**\n   * Use this method to set a custom notify function.\n   * This can be used to for example wrap notifications with `React.act` while running tests.\n   */\n\n\n  const setNotifyFunction = fn => {\n    notifyFn = fn;\n  };\n  /**\n   * Use this method to set a custom function to batch notifications together into a single tick.\n   * By default React Query will use the batch function provided by ReactDOM or React Native.\n   */\n\n\n  const setBatchNotifyFunction = fn => {\n    batchNotifyFn = fn;\n  };\n\n  return {\n    batch,\n    batchCalls,\n    schedule,\n    setNotifyFunction,\n    setBatchNotifyFunction\n  };\n} // SINGLETON\n\nconst notifyManager = createNotifyManager();\n\nclass Removable {\n  destroy() {\n    this.clearGcTimeout();\n  }\n\n  scheduleGc() {\n    this.clearGcTimeout();\n\n    if (isValidTimeout(this.cacheTime)) {\n      this.gcTimeout = setTimeout(() => {\n        this.optionalRemove();\n      }, this.cacheTime);\n    }\n  }\n\n  updateCacheTime(newCacheTime) {\n    // Default to 5 minutes (Infinity for server-side) if no cache time is set\n    this.cacheTime = Math.max(this.cacheTime || 0, newCacheTime != null ? newCacheTime : isServer ? Infinity : 5 * 60 * 1000);\n  }\n\n  clearGcTimeout() {\n    if (this.gcTimeout) {\n      clearTimeout(this.gcTimeout);\n      this.gcTimeout = undefined;\n    }\n  }\n\n}\n\n// CLASS\nclass Query extends Removable {\n  constructor(config) {\n    super();\n    this.abortSignalConsumed = false;\n    this.defaultOptions = config.defaultOptions;\n    this.setOptions(config.options);\n    this.observers = [];\n    this.cache = config.cache;\n    this.logger = config.logger || defaultLogger;\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    this.initialState = config.state || getDefaultState$1(this.options);\n    this.state = this.initialState;\n    this.meta = config.meta;\n  }\n\n  setOptions(options) {\n    this.options = { ...this.defaultOptions,\n      ...options\n    };\n    this.meta = options == null ? void 0 : options.meta;\n    this.updateCacheTime(this.options.cacheTime);\n  }\n\n  optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.cache.remove(this);\n    }\n  }\n\n  setData(newData, options) {\n    const data = replaceData(this.state.data, newData, this.options); // Set data and mark it as cached\n\n    this.dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options == null ? void 0 : options.updatedAt,\n      manual: options == null ? void 0 : options.manual\n    });\n    return data;\n  }\n\n  setState(state, setStateOptions) {\n    this.dispatch({\n      type: 'setState',\n      state,\n      setStateOptions\n    });\n  }\n\n  cancel(options) {\n    var _this$retryer;\n\n    const promise = this.promise;\n    (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.cancel(options);\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve();\n  }\n\n  destroy() {\n    super.destroy();\n    this.cancel({\n      silent: true\n    });\n  }\n\n  reset() {\n    this.destroy();\n    this.setState(this.initialState);\n  }\n\n  isActive() {\n    return this.observers.some(observer => observer.options.enabled !== false);\n  }\n\n  isDisabled() {\n    return this.getObserversCount() > 0 && !this.isActive();\n  }\n\n  isStale() {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some(observer => observer.getCurrentResult().isStale);\n  }\n\n  isStaleByTime(staleTime = 0) {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);\n  }\n\n  onFocus() {\n    var _this$retryer2;\n\n    const observer = this.observers.find(x => x.shouldFetchOnWindowFocus());\n\n    if (observer) {\n      observer.refetch({\n        cancelRefetch: false\n      });\n    } // Continue fetch if currently paused\n\n\n    (_this$retryer2 = this.retryer) == null ? void 0 : _this$retryer2.continue();\n  }\n\n  onOnline() {\n    var _this$retryer3;\n\n    const observer = this.observers.find(x => x.shouldFetchOnReconnect());\n\n    if (observer) {\n      observer.refetch({\n        cancelRefetch: false\n      });\n    } // Continue fetch if currently paused\n\n\n    (_this$retryer3 = this.retryer) == null ? void 0 : _this$retryer3.continue();\n  }\n\n  addObserver(observer) {\n    if (this.observers.indexOf(observer) === -1) {\n      this.observers.push(observer); // Stop the query from being garbage collected\n\n      this.clearGcTimeout();\n      this.cache.notify({\n        type: 'observerAdded',\n        query: this,\n        observer\n      });\n    }\n  }\n\n  removeObserver(observer) {\n    if (this.observers.indexOf(observer) !== -1) {\n      this.observers = this.observers.filter(x => x !== observer);\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.retryer) {\n          if (this.abortSignalConsumed) {\n            this.retryer.cancel({\n              revert: true\n            });\n          } else {\n            this.retryer.cancelRetry();\n          }\n        }\n\n        this.scheduleGc();\n      }\n\n      this.cache.notify({\n        type: 'observerRemoved',\n        query: this,\n        observer\n      });\n    }\n  }\n\n  getObserversCount() {\n    return this.observers.length;\n  }\n\n  invalidate() {\n    if (!this.state.isInvalidated) {\n      this.dispatch({\n        type: 'invalidate'\n      });\n    }\n  }\n\n  fetch(options, fetchOptions) {\n    var _this$options$behavio, _context$fetchOptions;\n\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.dataUpdatedAt && fetchOptions != null && fetchOptions.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetches\n        this.cancel({\n          silent: true\n        });\n      } else if (this.promise) {\n        var _this$retryer4;\n\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        (_this$retryer4 = this.retryer) == null ? void 0 : _this$retryer4.continueRetry(); // Return current promise if we are already fetching\n\n        return this.promise;\n      }\n    } // Update config if passed, otherwise the config from the last execution is used\n\n\n    if (options) {\n      this.setOptions(options);\n    } // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n\n\n    if (!this.options.queryFn) {\n      const observer = this.observers.find(x => x.options.queryFn);\n\n      if (observer) {\n        this.setOptions(observer.options);\n      }\n    }\n\n    if (!Array.isArray(this.options.queryKey)) {\n      if (process.env.NODE_ENV !== 'production') {\n        this.logger.error(\"As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']\");\n      }\n    }\n\n    const abortController = getAbortController(); // Create query function context\n\n    const queryFnContext = {\n      queryKey: this.queryKey,\n      pageParam: undefined,\n      meta: this.meta\n    }; // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n\n    const addSignalProperty = object => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          if (abortController) {\n            this.abortSignalConsumed = true;\n            return abortController.signal;\n          }\n\n          return undefined;\n        }\n      });\n    };\n\n    addSignalProperty(queryFnContext); // Create fetch function\n\n    const fetchFn = () => {\n      if (!this.options.queryFn) {\n        return Promise.reject('Missing queryFn');\n      }\n\n      this.abortSignalConsumed = false;\n      return this.options.queryFn(queryFnContext);\n    }; // Trigger behavior hook\n\n\n    const context = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn,\n      meta: this.meta\n    };\n    addSignalProperty(context);\n    (_this$options$behavio = this.options.behavior) == null ? void 0 : _this$options$behavio.onFetch(context); // Store state in case the current fetch needs to be reverted\n\n    this.revertState = this.state; // Set to fetching state if not already in it\n\n    if (this.state.fetchStatus === 'idle' || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) == null ? void 0 : _context$fetchOptions.meta)) {\n      var _context$fetchOptions2;\n\n      this.dispatch({\n        type: 'fetch',\n        meta: (_context$fetchOptions2 = context.fetchOptions) == null ? void 0 : _context$fetchOptions2.meta\n      });\n    }\n\n    const onError = error => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.dispatch({\n          type: 'error',\n          error: error\n        });\n      }\n\n      if (!isCancelledError(error)) {\n        var _this$cache$config$on, _this$cache$config;\n\n        // Notify cache callback\n        (_this$cache$config$on = (_this$cache$config = this.cache.config).onError) == null ? void 0 : _this$cache$config$on.call(_this$cache$config, error, this);\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error);\n        }\n      }\n\n      if (!this.isFetchingOptimistic) {\n        // Schedule query gc after fetching\n        this.scheduleGc();\n      }\n\n      this.isFetchingOptimistic = false;\n    }; // Try to fetch the data\n\n\n    this.retryer = createRetryer({\n      fn: context.fetchFn,\n      abort: abortController == null ? void 0 : abortController.abort.bind(abortController),\n      onSuccess: data => {\n        var _this$cache$config$on2, _this$cache$config2;\n\n        if (typeof data === 'undefined') {\n          onError(new Error('Query data cannot be undefined'));\n          return;\n        }\n\n        this.setData(data); // Notify cache callback\n\n        (_this$cache$config$on2 = (_this$cache$config2 = this.cache.config).onSuccess) == null ? void 0 : _this$cache$config$on2.call(_this$cache$config2, data, this);\n\n        if (!this.isFetchingOptimistic) {\n          // Schedule query gc after fetching\n          this.scheduleGc();\n        }\n\n        this.isFetchingOptimistic = false;\n      },\n      onError,\n      onFail: () => {\n        this.dispatch({\n          type: 'failed'\n        });\n      },\n      onPause: () => {\n        this.dispatch({\n          type: 'pause'\n        });\n      },\n      onContinue: () => {\n        this.dispatch({\n          type: 'continue'\n        });\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode\n    });\n    this.promise = this.retryer.promise;\n    return this.promise;\n  }\n\n  dispatch(action) {\n    const reducer = state => {\n      var _action$meta, _action$dataUpdatedAt;\n\n      switch (action.type) {\n        case 'failed':\n          return { ...state,\n            fetchFailureCount: state.fetchFailureCount + 1\n          };\n\n        case 'pause':\n          return { ...state,\n            fetchStatus: 'paused'\n          };\n\n        case 'continue':\n          return { ...state,\n            fetchStatus: 'fetching'\n          };\n\n        case 'fetch':\n          return { ...state,\n            fetchFailureCount: 0,\n            fetchMeta: (_action$meta = action.meta) != null ? _action$meta : null,\n            fetchStatus: canFetch(this.options.networkMode) ? 'fetching' : 'paused',\n            ...(!state.dataUpdatedAt && {\n              error: null,\n              status: 'loading'\n            })\n          };\n\n        case 'success':\n          return { ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) != null ? _action$dataUpdatedAt : Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0\n            })\n          };\n\n        case 'error':\n          const error = action.error;\n\n          if (isCancelledError(error) && error.revert && this.revertState) {\n            return { ...this.revertState\n            };\n          }\n\n          return { ...state,\n            error: error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchStatus: 'idle',\n            status: 'error'\n          };\n\n        case 'invalidate':\n          return { ...state,\n            isInvalidated: true\n          };\n\n        case 'setState':\n          return { ...state,\n            ...action.state\n          };\n      }\n    };\n\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onQueryUpdate(action);\n      });\n      this.cache.notify({\n        query: this,\n        type: 'updated',\n        action\n      });\n    });\n  }\n\n}\n\nfunction getDefaultState$1(options) {\n  const data = typeof options.initialData === 'function' ? options.initialData() : options.initialData;\n  const hasInitialData = typeof options.initialData !== 'undefined';\n  const initialDataUpdatedAt = hasInitialData ? typeof options.initialDataUpdatedAt === 'function' ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n  const hasData = typeof data !== 'undefined';\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt != null ? initialDataUpdatedAt : Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'loading',\n    fetchStatus: 'idle'\n  };\n}\n\n// CLASS\nclass QueryCache extends Subscribable {\n  constructor(config) {\n    super();\n    this.config = config || {};\n    this.queries = [];\n    this.queriesMap = {};\n  }\n\n  build(client, options, state) {\n    var _options$queryHash;\n\n    const queryKey = options.queryKey;\n    const queryHash = (_options$queryHash = options.queryHash) != null ? _options$queryHash : hashQueryKeyByOptions(queryKey, options);\n    let query = this.get(queryHash);\n\n    if (!query) {\n      query = new Query({\n        cache: this,\n        logger: client.getLogger(),\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey),\n        meta: options.meta\n      });\n      this.add(query);\n    }\n\n    return query;\n  }\n\n  add(query) {\n    if (!this.queriesMap[query.queryHash]) {\n      this.queriesMap[query.queryHash] = query;\n      this.queries.push(query);\n      this.notify({\n        type: 'added',\n        query\n      });\n    }\n  }\n\n  remove(query) {\n    const queryInMap = this.queriesMap[query.queryHash];\n\n    if (queryInMap) {\n      query.destroy();\n      this.queries = this.queries.filter(x => x !== query);\n\n      if (queryInMap === query) {\n        delete this.queriesMap[query.queryHash];\n      }\n\n      this.notify({\n        type: 'removed',\n        query\n      });\n    }\n  }\n\n  clear() {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        this.remove(query);\n      });\n    });\n  }\n\n  get(queryHash) {\n    return this.queriesMap[queryHash];\n  }\n\n  getAll() {\n    return this.queries;\n  }\n\n  find(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true;\n    }\n\n    return this.queries.find(query => matchQuery(filters, query));\n  }\n\n  findAll(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    return Object.keys(filters).length > 0 ? this.queries.filter(query => matchQuery(filters, query)) : this.queries;\n  }\n\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(event);\n      });\n    });\n  }\n\n  onFocus() {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        query.onFocus();\n      });\n    });\n  }\n\n  onOnline() {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        query.onOnline();\n      });\n    });\n  }\n\n}\n\n// CLASS\nclass Mutation extends Removable {\n  constructor(config) {\n    super();\n    this.options = { ...config.defaultOptions,\n      ...config.options\n    };\n    this.mutationId = config.mutationId;\n    this.mutationCache = config.mutationCache;\n    this.logger = config.logger || defaultLogger;\n    this.observers = [];\n    this.state = config.state || getDefaultState();\n    this.meta = config.meta;\n    this.updateCacheTime(this.options.cacheTime);\n    this.scheduleGc();\n  }\n\n  setState(state) {\n    this.dispatch({\n      type: 'setState',\n      state\n    });\n  }\n\n  addObserver(observer) {\n    if (this.observers.indexOf(observer) === -1) {\n      this.observers.push(observer); // Stop the mutation from being garbage collected\n\n      this.clearGcTimeout();\n      this.mutationCache.notify({\n        type: 'observerAdded',\n        mutation: this,\n        observer\n      });\n    }\n  }\n\n  removeObserver(observer) {\n    this.observers = this.observers.filter(x => x !== observer);\n    this.scheduleGc();\n    this.mutationCache.notify({\n      type: 'observerRemoved',\n      mutation: this,\n      observer\n    });\n  }\n\n  optionalRemove() {\n    if (!this.observers.length) {\n      if (this.state.status === 'loading') {\n        this.scheduleGc();\n      } else {\n        this.mutationCache.remove(this);\n      }\n    }\n  }\n\n  continue() {\n    if (this.retryer) {\n      this.retryer.continue();\n      return this.retryer.promise;\n    }\n\n    return this.execute();\n  }\n\n  async execute() {\n    const executeMutation = () => {\n      var _this$options$retry;\n\n      this.retryer = createRetryer({\n        fn: () => {\n          if (!this.options.mutationFn) {\n            return Promise.reject('No mutationFn found');\n          }\n\n          return this.options.mutationFn(this.state.variables);\n        },\n        onFail: () => {\n          this.dispatch({\n            type: 'failed'\n          });\n        },\n        onPause: () => {\n          this.dispatch({\n            type: 'pause'\n          });\n        },\n        onContinue: () => {\n          this.dispatch({\n            type: 'continue'\n          });\n        },\n        retry: (_this$options$retry = this.options.retry) != null ? _this$options$retry : 0,\n        retryDelay: this.options.retryDelay,\n        networkMode: this.options.networkMode\n      });\n      return this.retryer.promise;\n    };\n\n    const restored = this.state.status === 'loading';\n\n    try {\n      var _this$mutationCache$c3, _this$mutationCache$c4, _this$options$onSucce, _this$options2, _this$options$onSettl, _this$options3;\n\n      if (!restored) {\n        var _this$mutationCache$c, _this$mutationCache$c2, _this$options$onMutat, _this$options;\n\n        this.dispatch({\n          type: 'loading',\n          variables: this.options.variables\n        }); // Notify cache callback\n\n        (_this$mutationCache$c = (_this$mutationCache$c2 = this.mutationCache.config).onMutate) == null ? void 0 : _this$mutationCache$c.call(_this$mutationCache$c2, this.state.variables, this);\n        const context = await ((_this$options$onMutat = (_this$options = this.options).onMutate) == null ? void 0 : _this$options$onMutat.call(_this$options, this.state.variables));\n\n        if (context !== this.state.context) {\n          this.dispatch({\n            type: 'loading',\n            context,\n            variables: this.state.variables\n          });\n        }\n      }\n\n      const data = await executeMutation(); // Notify cache callback\n\n      (_this$mutationCache$c3 = (_this$mutationCache$c4 = this.mutationCache.config).onSuccess) == null ? void 0 : _this$mutationCache$c3.call(_this$mutationCache$c4, data, this.state.variables, this.state.context, this);\n      await ((_this$options$onSucce = (_this$options2 = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options2, data, this.state.variables, this.state.context));\n      await ((_this$options$onSettl = (_this$options3 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options3, data, null, this.state.variables, this.state.context));\n      this.dispatch({\n        type: 'success',\n        data\n      });\n      return data;\n    } catch (error) {\n      try {\n        var _this$mutationCache$c5, _this$mutationCache$c6, _this$options$onError, _this$options4, _this$options$onSettl2, _this$options5;\n\n        // Notify cache callback\n        (_this$mutationCache$c5 = (_this$mutationCache$c6 = this.mutationCache.config).onError) == null ? void 0 : _this$mutationCache$c5.call(_this$mutationCache$c6, error, this.state.variables, this.state.context, this);\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error);\n        }\n\n        await ((_this$options$onError = (_this$options4 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options4, error, this.state.variables, this.state.context));\n        await ((_this$options$onSettl2 = (_this$options5 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options5, undefined, error, this.state.variables, this.state.context));\n        throw error;\n      } finally {\n        this.dispatch({\n          type: 'error',\n          error: error\n        });\n      }\n    }\n  }\n\n  dispatch(action) {\n    const reducer = state => {\n      switch (action.type) {\n        case 'failed':\n          return { ...state,\n            failureCount: state.failureCount + 1\n          };\n\n        case 'pause':\n          return { ...state,\n            isPaused: true\n          };\n\n        case 'continue':\n          return { ...state,\n            isPaused: false\n          };\n\n        case 'loading':\n          return { ...state,\n            context: action.context,\n            data: undefined,\n            error: null,\n            isPaused: !canFetch(this.options.networkMode),\n            status: 'loading',\n            variables: action.variables\n          };\n\n        case 'success':\n          return { ...state,\n            data: action.data,\n            error: null,\n            status: 'success',\n            isPaused: false\n          };\n\n        case 'error':\n          return { ...state,\n            data: undefined,\n            error: action.error,\n            failureCount: state.failureCount + 1,\n            isPaused: false,\n            status: 'error'\n          };\n\n        case 'setState':\n          return { ...state,\n            ...action.state\n          };\n      }\n    };\n\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onMutationUpdate(action);\n      });\n      this.mutationCache.notify({\n        mutation: this,\n        type: 'updated',\n        action\n      });\n    });\n  }\n\n}\nfunction getDefaultState() {\n  return {\n    context: undefined,\n    data: undefined,\n    error: null,\n    failureCount: 0,\n    isPaused: false,\n    status: 'idle',\n    variables: undefined\n  };\n}\n\n// CLASS\nclass MutationCache extends Subscribable {\n  constructor(config) {\n    super();\n    this.config = config || {};\n    this.mutations = [];\n    this.mutationId = 0;\n  }\n\n  build(client, options, state) {\n    const mutation = new Mutation({\n      mutationCache: this,\n      logger: client.getLogger(),\n      mutationId: ++this.mutationId,\n      options: client.defaultMutationOptions(options),\n      state,\n      defaultOptions: options.mutationKey ? client.getMutationDefaults(options.mutationKey) : undefined,\n      meta: options.meta\n    });\n    this.add(mutation);\n    return mutation;\n  }\n\n  add(mutation) {\n    this.mutations.push(mutation);\n    this.notify({\n      type: 'added',\n      mutation\n    });\n  }\n\n  remove(mutation) {\n    this.mutations = this.mutations.filter(x => x !== mutation);\n    this.notify({\n      type: 'removed',\n      mutation\n    });\n  }\n\n  clear() {\n    notifyManager.batch(() => {\n      this.mutations.forEach(mutation => {\n        this.remove(mutation);\n      });\n    });\n  }\n\n  getAll() {\n    return this.mutations;\n  }\n\n  find(filters) {\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true;\n    }\n\n    return this.mutations.find(mutation => matchMutation(filters, mutation));\n  }\n\n  findAll(filters) {\n    return this.mutations.filter(mutation => matchMutation(filters, mutation));\n  }\n\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(event);\n      });\n    });\n  }\n\n  resumePausedMutations() {\n    const pausedMutations = this.mutations.filter(x => x.state.isPaused);\n    return notifyManager.batch(() => pausedMutations.reduce((promise, mutation) => promise.then(() => mutation.continue().catch(noop)), Promise.resolve()));\n  }\n\n}\n\nfunction infiniteQueryBehavior() {\n  return {\n    onFetch: context => {\n      context.fetchFn = () => {\n        var _context$fetchOptions, _context$fetchOptions2, _context$fetchOptions3, _context$fetchOptions4, _context$state$data, _context$state$data2;\n\n        const refetchPage = (_context$fetchOptions = context.fetchOptions) == null ? void 0 : (_context$fetchOptions2 = _context$fetchOptions.meta) == null ? void 0 : _context$fetchOptions2.refetchPage;\n        const fetchMore = (_context$fetchOptions3 = context.fetchOptions) == null ? void 0 : (_context$fetchOptions4 = _context$fetchOptions3.meta) == null ? void 0 : _context$fetchOptions4.fetchMore;\n        const pageParam = fetchMore == null ? void 0 : fetchMore.pageParam;\n        const isFetchingNextPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'forward';\n        const isFetchingPreviousPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'backward';\n        const oldPages = ((_context$state$data = context.state.data) == null ? void 0 : _context$state$data.pages) || [];\n        const oldPageParams = ((_context$state$data2 = context.state.data) == null ? void 0 : _context$state$data2.pageParams) || [];\n        let newPageParams = oldPageParams;\n        let cancelled = false;\n\n        const addSignalProperty = object => {\n          Object.defineProperty(object, 'signal', {\n            enumerable: true,\n            get: () => {\n              var _context$signal;\n\n              if ((_context$signal = context.signal) != null && _context$signal.aborted) {\n                cancelled = true;\n              } else {\n                var _context$signal2;\n\n                (_context$signal2 = context.signal) == null ? void 0 : _context$signal2.addEventListener('abort', () => {\n                  cancelled = true;\n                });\n              }\n\n              return context.signal;\n            }\n          });\n        }; // Get query function\n\n\n        const queryFn = context.options.queryFn || (() => Promise.reject('Missing queryFn'));\n\n        const buildNewPages = (pages, param, page, previous) => {\n          newPageParams = previous ? [param, ...newPageParams] : [...newPageParams, param];\n          return previous ? [page, ...pages] : [...pages, page];\n        }; // Create function to fetch a page\n\n\n        const fetchPage = (pages, manual, param, previous) => {\n          if (cancelled) {\n            return Promise.reject('Cancelled');\n          }\n\n          if (typeof param === 'undefined' && !manual && pages.length) {\n            return Promise.resolve(pages);\n          }\n\n          const queryFnContext = {\n            queryKey: context.queryKey,\n            pageParam: param,\n            meta: context.meta\n          };\n          addSignalProperty(queryFnContext);\n          const queryFnResult = queryFn(queryFnContext);\n          const promise = Promise.resolve(queryFnResult).then(page => buildNewPages(pages, param, page, previous));\n          return promise;\n        };\n\n        let promise; // Fetch first page?\n\n        if (!oldPages.length) {\n          promise = fetchPage([]);\n        } // Fetch next page?\n        else if (isFetchingNextPage) {\n          const manual = typeof pageParam !== 'undefined';\n          const param = manual ? pageParam : getNextPageParam(context.options, oldPages);\n          promise = fetchPage(oldPages, manual, param);\n        } // Fetch previous page?\n        else if (isFetchingPreviousPage) {\n          const manual = typeof pageParam !== 'undefined';\n          const param = manual ? pageParam : getPreviousPageParam(context.options, oldPages);\n          promise = fetchPage(oldPages, manual, param, true);\n        } // Refetch pages\n        else {\n          newPageParams = [];\n          const manual = typeof context.options.getNextPageParam === 'undefined';\n          const shouldFetchFirstPage = refetchPage && oldPages[0] ? refetchPage(oldPages[0], 0, oldPages) : true; // Fetch first page\n\n          promise = shouldFetchFirstPage ? fetchPage([], manual, oldPageParams[0]) : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0])); // Fetch remaining pages\n\n          for (let i = 1; i < oldPages.length; i++) {\n            promise = promise.then(pages => {\n              const shouldFetchNextPage = refetchPage && oldPages[i] ? refetchPage(oldPages[i], i, oldPages) : true;\n\n              if (shouldFetchNextPage) {\n                const param = manual ? oldPageParams[i] : getNextPageParam(context.options, pages);\n                return fetchPage(pages, manual, param);\n              }\n\n              return Promise.resolve(buildNewPages(pages, oldPageParams[i], oldPages[i]));\n            });\n          }\n        }\n\n        const finalPromise = promise.then(pages => ({\n          pages,\n          pageParams: newPageParams\n        }));\n        return finalPromise;\n      };\n    }\n  };\n}\nfunction getNextPageParam(options, pages) {\n  return options.getNextPageParam == null ? void 0 : options.getNextPageParam(pages[pages.length - 1], pages);\n}\nfunction getPreviousPageParam(options, pages) {\n  return options.getPreviousPageParam == null ? void 0 : options.getPreviousPageParam(pages[0], pages);\n}\n/**\n * Checks if there is a next page.\n * Returns `undefined` if it cannot be determined.\n */\n\nfunction hasNextPage(options, pages) {\n  if (options.getNextPageParam && Array.isArray(pages)) {\n    const nextPageParam = getNextPageParam(options, pages);\n    return typeof nextPageParam !== 'undefined' && nextPageParam !== null && nextPageParam !== false;\n  }\n}\n/**\n * Checks if there is a previous page.\n * Returns `undefined` if it cannot be determined.\n */\n\nfunction hasPreviousPage(options, pages) {\n  if (options.getPreviousPageParam && Array.isArray(pages)) {\n    const previousPageParam = getPreviousPageParam(options, pages);\n    return typeof previousPageParam !== 'undefined' && previousPageParam !== null && previousPageParam !== false;\n  }\n}\n\n// CLASS\nclass QueryClient {\n  constructor(config = {}) {\n    this.queryCache = config.queryCache || new QueryCache();\n    this.mutationCache = config.mutationCache || new MutationCache();\n    this.logger = config.logger || defaultLogger;\n    this.defaultOptions = config.defaultOptions || {};\n    this.queryDefaults = [];\n    this.mutationDefaults = [];\n  }\n\n  mount() {\n    this.unsubscribeFocus = focusManager.subscribe(() => {\n      if (focusManager.isFocused()) {\n        this.resumePausedMutations();\n        this.queryCache.onFocus();\n      }\n    });\n    this.unsubscribeOnline = onlineManager.subscribe(() => {\n      if (onlineManager.isOnline()) {\n        this.resumePausedMutations();\n        this.queryCache.onOnline();\n      }\n    });\n  }\n\n  unmount() {\n    var _this$unsubscribeFocu, _this$unsubscribeOnli;\n\n    (_this$unsubscribeFocu = this.unsubscribeFocus) == null ? void 0 : _this$unsubscribeFocu.call(this);\n    (_this$unsubscribeOnli = this.unsubscribeOnline) == null ? void 0 : _this$unsubscribeOnli.call(this);\n  }\n\n  isFetching(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    filters.fetchStatus = 'fetching';\n    return this.queryCache.findAll(filters).length;\n  }\n\n  isMutating(filters) {\n    return this.mutationCache.findAll({ ...filters,\n      fetching: true\n    }).length;\n  }\n\n  getQueryData(queryKey, filters) {\n    var _this$queryCache$find;\n\n    return (_this$queryCache$find = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find.state.data;\n  }\n\n  getQueriesData(queryKeyOrFilters) {\n    return this.getQueryCache().findAll(queryKeyOrFilters).map(({\n      queryKey,\n      state\n    }) => {\n      const data = state.data;\n      return [queryKey, data];\n    });\n  }\n\n  setQueryData(queryKey, updater, options) {\n    const query = this.queryCache.find(queryKey);\n    const prevData = query == null ? void 0 : query.state.data;\n    const data = functionalUpdate(updater, prevData);\n\n    if (typeof data === 'undefined') {\n      return undefined;\n    }\n\n    const parsedOptions = parseQueryArgs(queryKey);\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions);\n    return this.queryCache.build(this, defaultedOptions).setData(data, { ...options,\n      manual: true\n    });\n  }\n\n  setQueriesData(queryKeyOrFilters, updater, options) {\n    return notifyManager.batch(() => this.getQueryCache().findAll(queryKeyOrFilters).map(({\n      queryKey\n    }) => [queryKey, this.setQueryData(queryKey, updater, options)]));\n  }\n\n  getQueryState(queryKey, filters) {\n    var _this$queryCache$find2;\n\n    return (_this$queryCache$find2 = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find2.state;\n  }\n\n  removeQueries(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    const queryCache = this.queryCache;\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        queryCache.remove(query);\n      });\n    });\n  }\n\n  resetQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    const queryCache = this.queryCache;\n    const refetchFilters = {\n      type: 'active',\n      ...filters\n    };\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        query.reset();\n      });\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n\n  cancelQueries(arg1, arg2, arg3) {\n    const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3);\n\n    if (typeof cancelOptions.revert === 'undefined') {\n      cancelOptions.revert = true;\n    }\n\n    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).map(query => query.cancel(cancelOptions)));\n    return Promise.all(promises).then(noop).catch(noop);\n  }\n\n  invalidateQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    return notifyManager.batch(() => {\n      var _ref, _filters$refetchType;\n\n      this.queryCache.findAll(filters).forEach(query => {\n        query.invalidate();\n      });\n\n      if (filters.refetchType === 'none') {\n        return Promise.resolve();\n      }\n\n      const refetchFilters = { ...filters,\n        type: (_ref = (_filters$refetchType = filters.refetchType) != null ? _filters$refetchType : filters.type) != null ? _ref : 'active'\n      };\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n\n  refetchQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).filter(query => !query.isDisabled()).map(query => {\n      var _options$cancelRefetc;\n\n      return query.fetch(undefined, { ...options,\n        cancelRefetch: (_options$cancelRefetc = options == null ? void 0 : options.cancelRefetch) != null ? _options$cancelRefetc : true,\n        meta: {\n          refetchPage: filters.refetchPage\n        }\n      });\n    }));\n    let promise = Promise.all(promises).then(noop);\n\n    if (!(options != null && options.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  }\n\n  fetchQuery(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions); // https://github.com/tannerlinsley/react-query/issues/652\n\n    if (typeof defaultedOptions.retry === 'undefined') {\n      defaultedOptions.retry = false;\n    }\n\n    const query = this.queryCache.build(this, defaultedOptions);\n    return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);\n  }\n\n  prefetchQuery(arg1, arg2, arg3) {\n    return this.fetchQuery(arg1, arg2, arg3).then(noop).catch(noop);\n  }\n\n  fetchInfiniteQuery(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    parsedOptions.behavior = infiniteQueryBehavior();\n    return this.fetchQuery(parsedOptions);\n  }\n\n  prefetchInfiniteQuery(arg1, arg2, arg3) {\n    return this.fetchInfiniteQuery(arg1, arg2, arg3).then(noop).catch(noop);\n  }\n\n  resumePausedMutations() {\n    return this.mutationCache.resumePausedMutations();\n  }\n\n  getQueryCache() {\n    return this.queryCache;\n  }\n\n  getMutationCache() {\n    return this.mutationCache;\n  }\n\n  getLogger() {\n    return this.logger;\n  }\n\n  getDefaultOptions() {\n    return this.defaultOptions;\n  }\n\n  setDefaultOptions(options) {\n    this.defaultOptions = options;\n  }\n\n  setQueryDefaults(queryKey, options) {\n    const result = this.queryDefaults.find(x => hashQueryKey(queryKey) === hashQueryKey(x.queryKey));\n\n    if (result) {\n      result.defaultOptions = options;\n    } else {\n      this.queryDefaults.push({\n        queryKey,\n        defaultOptions: options\n      });\n    }\n  }\n\n  getQueryDefaults(queryKey) {\n    if (!queryKey) {\n      return undefined;\n    } // Get the first matching defaults\n\n\n    const firstMatchingDefaults = this.queryDefaults.find(x => partialMatchKey(queryKey, x.queryKey)); // Additional checks and error in dev mode\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.queryDefaults.filter(x => partialMatchKey(queryKey, x.queryKey)); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n\n      if (matchingDefaults.length > 1) {\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(\"[QueryClient] Several query defaults match with key '\" + JSON.stringify(queryKey) + \"'. The first matching query defaults are used. Please check how query defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults.\");\n        }\n      }\n    }\n\n    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n  }\n\n  setMutationDefaults(mutationKey, options) {\n    const result = this.mutationDefaults.find(x => hashQueryKey(mutationKey) === hashQueryKey(x.mutationKey));\n\n    if (result) {\n      result.defaultOptions = options;\n    } else {\n      this.mutationDefaults.push({\n        mutationKey,\n        defaultOptions: options\n      });\n    }\n  }\n\n  getMutationDefaults(mutationKey) {\n    if (!mutationKey) {\n      return undefined;\n    } // Get the first matching defaults\n\n\n    const firstMatchingDefaults = this.mutationDefaults.find(x => partialMatchKey(mutationKey, x.mutationKey)); // Additional checks and error in dev mode\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.mutationDefaults.filter(x => partialMatchKey(mutationKey, x.mutationKey)); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n\n      if (matchingDefaults.length > 1) {\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(\"[QueryClient] Several mutation defaults match with key '\" + JSON.stringify(mutationKey) + \"'. The first matching mutation defaults are used. Please check how mutation defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetmutationdefaults.\");\n        }\n      }\n    }\n\n    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n  }\n\n  defaultQueryOptions(options) {\n    if (options != null && options._defaulted) {\n      return options;\n    }\n\n    const defaultedOptions = { ...this.defaultOptions.queries,\n      ...this.getQueryDefaults(options == null ? void 0 : options.queryKey),\n      ...options,\n      _defaulted: true\n    };\n\n    if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(defaultedOptions.queryKey, defaultedOptions);\n    } // dependent default values\n\n\n    if (typeof defaultedOptions.refetchOnReconnect === 'undefined') {\n      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== 'always';\n    }\n\n    if (typeof defaultedOptions.useErrorBoundary === 'undefined') {\n      defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense;\n    }\n\n    return defaultedOptions;\n  }\n\n  defaultMutationOptions(options) {\n    if (options != null && options._defaulted) {\n      return options;\n    }\n\n    return { ...this.defaultOptions.mutations,\n      ...this.getMutationDefaults(options == null ? void 0 : options.mutationKey),\n      ...options,\n      _defaulted: true\n    };\n  }\n\n  clear() {\n    this.queryCache.clear();\n    this.mutationCache.clear();\n  }\n\n}\n\nclass QueryObserver extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.client = client;\n    this.options = options;\n    this.trackedProps = new Set();\n    this.selectError = null;\n    this.bindMethods();\n    this.setOptions(options);\n  }\n\n  bindMethods() {\n    this.remove = this.remove.bind(this);\n    this.refetch = this.refetch.bind(this);\n  }\n\n  onSubscribe() {\n    if (this.listeners.length === 1) {\n      this.currentQuery.addObserver(this);\n\n      if (shouldFetchOnMount(this.currentQuery, this.options)) {\n        this.executeFetch();\n      }\n\n      this.updateTimers();\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.listeners.length) {\n      this.destroy();\n    }\n  }\n\n  shouldFetchOnReconnect() {\n    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnReconnect);\n  }\n\n  shouldFetchOnWindowFocus() {\n    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnWindowFocus);\n  }\n\n  destroy() {\n    this.listeners = [];\n    this.clearStaleTimeout();\n    this.clearRefetchInterval();\n    this.currentQuery.removeObserver(this);\n  }\n\n  setOptions(options, notifyOptions) {\n    const prevOptions = this.options;\n    const prevQuery = this.currentQuery;\n    this.options = this.client.defaultQueryOptions(options);\n\n    if (typeof this.options.enabled !== 'undefined' && typeof this.options.enabled !== 'boolean') {\n      throw new Error('Expected enabled to be a boolean');\n    } // Keep previous query key if the user does not supply one\n\n\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey;\n    }\n\n    this.updateQuery();\n    const mounted = this.hasListeners(); // Fetch if there are subscribers\n\n    if (mounted && shouldFetchOptionally(this.currentQuery, prevQuery, this.options, prevOptions)) {\n      this.executeFetch();\n    } // Update result\n\n\n    this.updateResult(notifyOptions); // Update stale interval if needed\n\n    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {\n      this.updateStaleTimeout();\n    }\n\n    const nextRefetchInterval = this.computeRefetchInterval(); // Update refetch interval if needed\n\n    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.currentRefetchInterval)) {\n      this.updateRefetchInterval(nextRefetchInterval);\n    }\n  }\n\n  getOptimisticResult(options) {\n    const query = this.client.getQueryCache().build(this.client, options);\n    return this.createResult(query, options);\n  }\n\n  getCurrentResult() {\n    return this.currentResult;\n  }\n\n  trackResult(result) {\n    const trackedResult = {};\n    Object.keys(result).forEach(key => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.trackedProps.add(key);\n          return result[key];\n        }\n      });\n    });\n    return trackedResult;\n  }\n\n  getCurrentQuery() {\n    return this.currentQuery;\n  }\n\n  remove() {\n    this.client.getQueryCache().remove(this.currentQuery);\n  }\n\n  refetch({\n    refetchPage,\n    ...options\n  } = {}) {\n    return this.fetch({ ...options,\n      meta: {\n        refetchPage\n      }\n    });\n  }\n\n  fetchOptimistic(options) {\n    const defaultedOptions = this.client.defaultQueryOptions(options);\n    const query = this.client.getQueryCache().build(this.client, defaultedOptions);\n    query.isFetchingOptimistic = true;\n    return query.fetch().then(() => this.createResult(query, defaultedOptions));\n  }\n\n  fetch(fetchOptions) {\n    var _fetchOptions$cancelR;\n\n    return this.executeFetch({ ...fetchOptions,\n      cancelRefetch: (_fetchOptions$cancelR = fetchOptions.cancelRefetch) != null ? _fetchOptions$cancelR : true\n    }).then(() => {\n      this.updateResult();\n      return this.currentResult;\n    });\n  }\n\n  executeFetch(fetchOptions) {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.updateQuery(); // Fetch\n\n    let promise = this.currentQuery.fetch(this.options, fetchOptions);\n\n    if (!(fetchOptions != null && fetchOptions.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  }\n\n  updateStaleTimeout() {\n    this.clearStaleTimeout();\n\n    if (isServer || this.currentResult.isStale || !isValidTimeout(this.options.staleTime)) {\n      return;\n    }\n\n    const time = timeUntilStale(this.currentResult.dataUpdatedAt, this.options.staleTime); // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n\n    const timeout = time + 1;\n    this.staleTimeoutId = setTimeout(() => {\n      if (!this.currentResult.isStale) {\n        this.updateResult();\n      }\n    }, timeout);\n  }\n\n  computeRefetchInterval() {\n    var _this$options$refetch;\n\n    return typeof this.options.refetchInterval === 'function' ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (_this$options$refetch = this.options.refetchInterval) != null ? _this$options$refetch : false;\n  }\n\n  updateRefetchInterval(nextInterval) {\n    this.clearRefetchInterval();\n    this.currentRefetchInterval = nextInterval;\n\n    if (isServer || this.options.enabled === false || !isValidTimeout(this.currentRefetchInterval) || this.currentRefetchInterval === 0) {\n      return;\n    }\n\n    this.refetchIntervalId = setInterval(() => {\n      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {\n        this.executeFetch();\n      }\n    }, this.currentRefetchInterval);\n  }\n\n  updateTimers() {\n    this.updateStaleTimeout();\n    this.updateRefetchInterval(this.computeRefetchInterval());\n  }\n\n  clearStaleTimeout() {\n    if (this.staleTimeoutId) {\n      clearTimeout(this.staleTimeoutId);\n      this.staleTimeoutId = undefined;\n    }\n  }\n\n  clearRefetchInterval() {\n    if (this.refetchIntervalId) {\n      clearInterval(this.refetchIntervalId);\n      this.refetchIntervalId = undefined;\n    }\n  }\n\n  createResult(query, options) {\n    const prevQuery = this.currentQuery;\n    const prevOptions = this.options;\n    const prevResult = this.currentResult;\n    const prevResultState = this.currentResultState;\n    const prevResultOptions = this.currentResultOptions;\n    const queryChange = query !== prevQuery;\n    const queryInitialState = queryChange ? query.state : this.currentQueryInitialState;\n    const prevQueryResult = queryChange ? this.currentResult : this.previousQueryResult;\n    const {\n      state\n    } = query;\n    let {\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      fetchStatus,\n      status\n    } = state;\n    let isPreviousData = false;\n    let isPlaceholderData = false;\n    let data; // Optimistically set result in fetching state if needed\n\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners();\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n\n      if (fetchOnMount || fetchOptionally) {\n        fetchStatus = canFetch(query.options.networkMode) ? 'fetching' : 'paused';\n\n        if (!dataUpdatedAt) {\n          status = 'loading';\n        }\n      }\n\n      if (options._optimisticResults === 'isRestoring') {\n        fetchStatus = 'idle';\n      }\n    } // Keep previous data if needed\n\n\n    if (options.keepPreviousData && !state.dataUpdateCount && prevQueryResult != null && prevQueryResult.isSuccess && status !== 'error') {\n      data = prevQueryResult.data;\n      dataUpdatedAt = prevQueryResult.dataUpdatedAt;\n      status = prevQueryResult.status;\n      isPreviousData = true;\n    } // Select data if needed\n    else if (options.select && typeof state.data !== 'undefined') {\n      // Memoize select result\n      if (prevResult && state.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === this.selectFn) {\n        data = this.selectResult;\n      } else {\n        try {\n          this.selectFn = options.select;\n          data = options.select(state.data);\n          data = replaceData(prevResult == null ? void 0 : prevResult.data, data, options);\n          this.selectResult = data;\n          this.selectError = null;\n        } catch (selectError) {\n          if (process.env.NODE_ENV !== 'production') {\n            this.client.getLogger().error(selectError);\n          }\n\n          this.selectError = selectError;\n        }\n      }\n    } // Use query data\n    else {\n      data = state.data;\n    } // Show placeholder data if needed\n\n\n    if (typeof options.placeholderData !== 'undefined' && typeof data === 'undefined' && status === 'loading') {\n      let placeholderData; // Memoize placeholder data\n\n      if (prevResult != null && prevResult.isPlaceholderData && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {\n        placeholderData = prevResult.data;\n      } else {\n        placeholderData = typeof options.placeholderData === 'function' ? options.placeholderData() : options.placeholderData;\n\n        if (options.select && typeof placeholderData !== 'undefined') {\n          try {\n            placeholderData = options.select(placeholderData);\n            placeholderData = replaceData(prevResult == null ? void 0 : prevResult.data, placeholderData, options);\n            this.selectError = null;\n          } catch (selectError) {\n            if (process.env.NODE_ENV !== 'production') {\n              this.client.getLogger().error(selectError);\n            }\n\n            this.selectError = selectError;\n          }\n        }\n      }\n\n      if (typeof placeholderData !== 'undefined') {\n        status = 'success';\n        data = placeholderData;\n        isPlaceholderData = true;\n      }\n    }\n\n    if (this.selectError) {\n      error = this.selectError;\n      data = this.selectResult;\n      errorUpdatedAt = Date.now();\n      status = 'error';\n    }\n\n    const isFetching = fetchStatus === 'fetching';\n    const result = {\n      status,\n      fetchStatus,\n      isLoading: status === 'loading',\n      isSuccess: status === 'success',\n      isError: status === 'error',\n      data,\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: state.fetchFailureCount,\n      errorUpdateCount: state.errorUpdateCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount: state.dataUpdateCount > queryInitialState.dataUpdateCount || state.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching: isFetching,\n      isRefetching: isFetching && status !== 'loading',\n      isLoadingError: status === 'error' && state.dataUpdatedAt === 0,\n      isPaused: fetchStatus === 'paused',\n      isPlaceholderData,\n      isPreviousData,\n      isRefetchError: status === 'error' && state.dataUpdatedAt !== 0,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      remove: this.remove\n    };\n    return result;\n  }\n\n  updateResult(notifyOptions) {\n    const prevResult = this.currentResult;\n    const nextResult = this.createResult(this.currentQuery, this.options);\n    this.currentResultState = this.currentQuery.state;\n    this.currentResultOptions = this.options; // Only notify and update result if something has changed\n\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return;\n    }\n\n    this.currentResult = nextResult; // Determine which callbacks to trigger\n\n    const defaultNotifyOptions = {\n      cache: true\n    };\n\n    const shouldNotifyListeners = () => {\n      if (!prevResult) {\n        return true;\n      }\n\n      const {\n        notifyOnChangeProps\n      } = this.options;\n\n      if (notifyOnChangeProps === 'all' || !notifyOnChangeProps && !this.trackedProps.size) {\n        return true;\n      }\n\n      const includedProps = new Set(notifyOnChangeProps != null ? notifyOnChangeProps : this.trackedProps);\n\n      if (this.options.useErrorBoundary) {\n        includedProps.add('error');\n      }\n\n      return Object.keys(this.currentResult).some(key => {\n        const typedKey = key;\n        const changed = this.currentResult[typedKey] !== prevResult[typedKey];\n        return changed && includedProps.has(typedKey);\n      });\n    };\n\n    if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && shouldNotifyListeners()) {\n      defaultNotifyOptions.listeners = true;\n    }\n\n    this.notify({ ...defaultNotifyOptions,\n      ...notifyOptions\n    });\n  }\n\n  updateQuery() {\n    const query = this.client.getQueryCache().build(this.client, this.options);\n\n    if (query === this.currentQuery) {\n      return;\n    }\n\n    const prevQuery = this.currentQuery;\n    this.currentQuery = query;\n    this.currentQueryInitialState = query.state;\n    this.previousQueryResult = this.currentResult;\n\n    if (this.hasListeners()) {\n      prevQuery == null ? void 0 : prevQuery.removeObserver(this);\n      query.addObserver(this);\n    }\n  }\n\n  onQueryUpdate(action) {\n    const notifyOptions = {};\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = !action.manual;\n    } else if (action.type === 'error' && !isCancelledError(action.error)) {\n      notifyOptions.onError = true;\n    }\n\n    this.updateResult(notifyOptions);\n\n    if (this.hasListeners()) {\n      this.updateTimers();\n    }\n  }\n\n  notify(notifyOptions) {\n    notifyManager.batch(() => {\n      // First trigger the configuration callbacks\n      if (notifyOptions.onSuccess) {\n        var _this$options$onSucce, _this$options, _this$options$onSettl, _this$options2;\n\n        (_this$options$onSucce = (_this$options = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options, this.currentResult.data);\n        (_this$options$onSettl = (_this$options2 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options2, this.currentResult.data, null);\n      } else if (notifyOptions.onError) {\n        var _this$options$onError, _this$options3, _this$options$onSettl2, _this$options4;\n\n        (_this$options$onError = (_this$options3 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options3, this.currentResult.error);\n        (_this$options$onSettl2 = (_this$options4 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options4, undefined, this.currentResult.error);\n      } // Then trigger the listeners\n\n\n      if (notifyOptions.listeners) {\n        this.listeners.forEach(listener => {\n          listener(this.currentResult);\n        });\n      } // Then the cache listeners\n\n\n      if (notifyOptions.cache) {\n        this.client.getQueryCache().notify({\n          query: this.currentQuery,\n          type: 'observerResultsUpdated'\n        });\n      }\n    });\n  }\n\n}\n\nfunction shouldLoadOnMount(query, options) {\n  return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === 'error' && options.retryOnMount === false);\n}\n\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\n\nfunction shouldFetchOn(query, options, field) {\n  if (options.enabled !== false) {\n    const value = typeof field === 'function' ? field(query) : field;\n    return value === 'always' || value !== false && isStale(query, options);\n  }\n\n  return false;\n}\n\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return options.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== 'error') && isStale(query, options);\n}\n\nfunction isStale(query, options) {\n  return query.isStaleByTime(options.staleTime);\n}\n\nclass QueriesObserver extends Subscribable {\n  constructor(client, queries) {\n    super();\n    this.client = client;\n    this.queries = [];\n    this.result = [];\n    this.observers = [];\n    this.observersMap = {};\n\n    if (queries) {\n      this.setQueries(queries);\n    }\n  }\n\n  onSubscribe() {\n    if (this.listeners.length === 1) {\n      this.observers.forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result);\n        });\n      });\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.listeners.length) {\n      this.destroy();\n    }\n  }\n\n  destroy() {\n    this.listeners = [];\n    this.observers.forEach(observer => {\n      observer.destroy();\n    });\n  }\n\n  setQueries(queries, notifyOptions) {\n    this.queries = queries;\n    notifyManager.batch(() => {\n      const prevObservers = this.observers;\n      const newObserverMatches = this.findMatchingObservers(this.queries); // set options for the new observers to notify of changes\n\n      newObserverMatches.forEach(match => match.observer.setOptions(match.defaultedQueryOptions, notifyOptions));\n      const newObservers = newObserverMatches.map(match => match.observer);\n      const newObserversMap = Object.fromEntries(newObservers.map(observer => [observer.options.queryHash, observer]));\n      const newResult = newObservers.map(observer => observer.getCurrentResult());\n      const hasIndexChange = newObservers.some((observer, index) => observer !== prevObservers[index]);\n\n      if (prevObservers.length === newObservers.length && !hasIndexChange) {\n        return;\n      }\n\n      this.observers = newObservers;\n      this.observersMap = newObserversMap;\n      this.result = newResult;\n\n      if (!this.hasListeners()) {\n        return;\n      }\n\n      difference(prevObservers, newObservers).forEach(observer => {\n        observer.destroy();\n      });\n      difference(newObservers, prevObservers).forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result);\n        });\n      });\n      this.notify();\n    });\n  }\n\n  getCurrentResult() {\n    return this.result;\n  }\n\n  getOptimisticResult(queries) {\n    return this.findMatchingObservers(queries).map(match => match.observer.getOptimisticResult(match.defaultedQueryOptions));\n  }\n\n  findMatchingObservers(queries) {\n    const prevObservers = this.observers;\n    const defaultedQueryOptions = queries.map(options => this.client.defaultQueryOptions(options));\n    const matchingObservers = defaultedQueryOptions.flatMap(defaultedOptions => {\n      const match = prevObservers.find(observer => observer.options.queryHash === defaultedOptions.queryHash);\n\n      if (match != null) {\n        return [{\n          defaultedQueryOptions: defaultedOptions,\n          observer: match\n        }];\n      }\n\n      return [];\n    });\n    const matchedQueryHashes = matchingObservers.map(match => match.defaultedQueryOptions.queryHash);\n    const unmatchedQueries = defaultedQueryOptions.filter(defaultedOptions => !matchedQueryHashes.includes(defaultedOptions.queryHash));\n    const unmatchedObservers = prevObservers.filter(prevObserver => !matchingObservers.some(match => match.observer === prevObserver));\n\n    const getObserver = options => {\n      const defaultedOptions = this.client.defaultQueryOptions(options);\n      const currentObserver = this.observersMap[defaultedOptions.queryHash];\n      return currentObserver != null ? currentObserver : new QueryObserver(this.client, defaultedOptions);\n    };\n\n    const newOrReusedObservers = unmatchedQueries.map((options, index) => {\n      if (options.keepPreviousData) {\n        // return previous data from one of the observers that no longer match\n        const previouslyUsedObserver = unmatchedObservers[index];\n\n        if (previouslyUsedObserver !== undefined) {\n          return {\n            defaultedQueryOptions: options,\n            observer: previouslyUsedObserver\n          };\n        }\n      }\n\n      return {\n        defaultedQueryOptions: options,\n        observer: getObserver(options)\n      };\n    });\n\n    const sortMatchesByOrderOfQueries = (a, b) => defaultedQueryOptions.indexOf(a.defaultedQueryOptions) - defaultedQueryOptions.indexOf(b.defaultedQueryOptions);\n\n    return matchingObservers.concat(newOrReusedObservers).sort(sortMatchesByOrderOfQueries);\n  }\n\n  onUpdate(observer, result) {\n    const index = this.observers.indexOf(observer);\n\n    if (index !== -1) {\n      this.result = replaceAt(this.result, index, result);\n      this.notify();\n    }\n  }\n\n  notify() {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(this.result);\n      });\n    });\n  }\n\n}\n\nclass InfiniteQueryObserver extends QueryObserver {\n  // Type override\n  // Type override\n  // Type override\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor(client, options) {\n    super(client, options);\n  }\n\n  bindMethods() {\n    super.bindMethods();\n    this.fetchNextPage = this.fetchNextPage.bind(this);\n    this.fetchPreviousPage = this.fetchPreviousPage.bind(this);\n  }\n\n  setOptions(options, notifyOptions) {\n    super.setOptions({ ...options,\n      behavior: infiniteQueryBehavior()\n    }, notifyOptions);\n  }\n\n  getOptimisticResult(options) {\n    options.behavior = infiniteQueryBehavior();\n    return super.getOptimisticResult(options);\n  }\n\n  fetchNextPage({\n    pageParam,\n    ...options\n  } = {}) {\n    return this.fetch({ ...options,\n      meta: {\n        fetchMore: {\n          direction: 'forward',\n          pageParam\n        }\n      }\n    });\n  }\n\n  fetchPreviousPage({\n    pageParam,\n    ...options\n  } = {}) {\n    return this.fetch({ ...options,\n      meta: {\n        fetchMore: {\n          direction: 'backward',\n          pageParam\n        }\n      }\n    });\n  }\n\n  createResult(query, options) {\n    var _state$data, _state$data2, _state$fetchMeta, _state$fetchMeta$fetc, _state$fetchMeta2, _state$fetchMeta2$fet;\n\n    const {\n      state\n    } = query;\n    const result = super.createResult(query, options);\n    return { ...result,\n      fetchNextPage: this.fetchNextPage,\n      fetchPreviousPage: this.fetchPreviousPage,\n      hasNextPage: hasNextPage(options, (_state$data = state.data) == null ? void 0 : _state$data.pages),\n      hasPreviousPage: hasPreviousPage(options, (_state$data2 = state.data) == null ? void 0 : _state$data2.pages),\n      isFetchingNextPage: state.fetchStatus === 'fetching' && ((_state$fetchMeta = state.fetchMeta) == null ? void 0 : (_state$fetchMeta$fetc = _state$fetchMeta.fetchMore) == null ? void 0 : _state$fetchMeta$fetc.direction) === 'forward',\n      isFetchingPreviousPage: state.fetchStatus === 'fetching' && ((_state$fetchMeta2 = state.fetchMeta) == null ? void 0 : (_state$fetchMeta2$fet = _state$fetchMeta2.fetchMore) == null ? void 0 : _state$fetchMeta2$fet.direction) === 'backward'\n    };\n  }\n\n}\n\n// CLASS\nclass MutationObserver extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.client = client;\n    this.setOptions(options);\n    this.bindMethods();\n    this.updateResult();\n  }\n\n  bindMethods() {\n    this.mutate = this.mutate.bind(this);\n    this.reset = this.reset.bind(this);\n  }\n\n  setOptions(options) {\n    this.options = this.client.defaultMutationOptions(options);\n  }\n\n  onUnsubscribe() {\n    if (!this.listeners.length) {\n      var _this$currentMutation;\n\n      (_this$currentMutation = this.currentMutation) == null ? void 0 : _this$currentMutation.removeObserver(this);\n    }\n  }\n\n  onMutationUpdate(action) {\n    this.updateResult(); // Determine which callbacks to trigger\n\n    const notifyOptions = {\n      listeners: true\n    };\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = true;\n    } else if (action.type === 'error') {\n      notifyOptions.onError = true;\n    }\n\n    this.notify(notifyOptions);\n  }\n\n  getCurrentResult() {\n    return this.currentResult;\n  }\n\n  reset() {\n    this.currentMutation = undefined;\n    this.updateResult();\n    this.notify({\n      listeners: true\n    });\n  }\n\n  mutate(variables, options) {\n    this.mutateOptions = options;\n\n    if (this.currentMutation) {\n      this.currentMutation.removeObserver(this);\n    }\n\n    this.currentMutation = this.client.getMutationCache().build(this.client, { ...this.options,\n      variables: typeof variables !== 'undefined' ? variables : this.options.variables\n    });\n    this.currentMutation.addObserver(this);\n    return this.currentMutation.execute();\n  }\n\n  updateResult() {\n    const state = this.currentMutation ? this.currentMutation.state : getDefaultState();\n    const result = { ...state,\n      isLoading: state.status === 'loading',\n      isSuccess: state.status === 'success',\n      isError: state.status === 'error',\n      isIdle: state.status === 'idle',\n      mutate: this.mutate,\n      reset: this.reset\n    };\n    this.currentResult = result;\n  }\n\n  notify(options) {\n    notifyManager.batch(() => {\n      // First trigger the mutate callbacks\n      if (this.mutateOptions) {\n        if (options.onSuccess) {\n          var _this$mutateOptions$o, _this$mutateOptions, _this$mutateOptions$o2, _this$mutateOptions2;\n\n          (_this$mutateOptions$o = (_this$mutateOptions = this.mutateOptions).onSuccess) == null ? void 0 : _this$mutateOptions$o.call(_this$mutateOptions, this.currentResult.data, this.currentResult.variables, this.currentResult.context);\n          (_this$mutateOptions$o2 = (_this$mutateOptions2 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o2.call(_this$mutateOptions2, this.currentResult.data, null, this.currentResult.variables, this.currentResult.context);\n        } else if (options.onError) {\n          var _this$mutateOptions$o3, _this$mutateOptions3, _this$mutateOptions$o4, _this$mutateOptions4;\n\n          (_this$mutateOptions$o3 = (_this$mutateOptions3 = this.mutateOptions).onError) == null ? void 0 : _this$mutateOptions$o3.call(_this$mutateOptions3, this.currentResult.error, this.currentResult.variables, this.currentResult.context);\n          (_this$mutateOptions$o4 = (_this$mutateOptions4 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o4.call(_this$mutateOptions4, undefined, this.currentResult.error, this.currentResult.variables, this.currentResult.context);\n        }\n      } // Then trigger the listeners\n\n\n      if (options.listeners) {\n        this.listeners.forEach(listener => {\n          listener(this.currentResult);\n        });\n      }\n    });\n  }\n\n}\n\n// TYPES\n// FUNCTIONS\nfunction dehydrateMutation(mutation) {\n  return {\n    mutationKey: mutation.options.mutationKey,\n    state: mutation.state\n  };\n} // Most config is not dehydrated but instead meant to configure again when\n// consuming the de/rehydrated data, typically with useQuery on the client.\n// Sometimes it might make sense to prefetch data on the server and include\n// in the html-payload, but not consume it on the initial render.\n\n\nfunction dehydrateQuery(query) {\n  return {\n    state: query.state,\n    queryKey: query.queryKey,\n    queryHash: query.queryHash\n  };\n}\n\nfunction defaultShouldDehydrateMutation(mutation) {\n  return mutation.state.isPaused;\n}\n\nfunction defaultShouldDehydrateQuery(query) {\n  return query.state.status === 'success';\n}\n\nfunction dehydrate(client, options = {}) {\n  const mutations = [];\n  const queries = [];\n\n  if (options.dehydrateMutations !== false) {\n    const shouldDehydrateMutation = options.shouldDehydrateMutation || defaultShouldDehydrateMutation;\n    client.getMutationCache().getAll().forEach(mutation => {\n      if (shouldDehydrateMutation(mutation)) {\n        mutations.push(dehydrateMutation(mutation));\n      }\n    });\n  }\n\n  if (options.dehydrateQueries !== false) {\n    const shouldDehydrateQuery = options.shouldDehydrateQuery || defaultShouldDehydrateQuery;\n    client.getQueryCache().getAll().forEach(query => {\n      if (shouldDehydrateQuery(query)) {\n        queries.push(dehydrateQuery(query));\n      }\n    });\n  }\n\n  return {\n    mutations,\n    queries\n  };\n}\nfunction hydrate(client, dehydratedState, options) {\n  if (typeof dehydratedState !== 'object' || dehydratedState === null) {\n    return;\n  }\n\n  const mutationCache = client.getMutationCache();\n  const queryCache = client.getQueryCache(); // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\n  const mutations = dehydratedState.mutations || []; // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\n  const queries = dehydratedState.queries || [];\n  mutations.forEach(dehydratedMutation => {\n    var _options$defaultOptio;\n\n    mutationCache.build(client, { ...(options == null ? void 0 : (_options$defaultOptio = options.defaultOptions) == null ? void 0 : _options$defaultOptio.mutations),\n      mutationKey: dehydratedMutation.mutationKey\n    }, dehydratedMutation.state);\n  });\n  queries.forEach(dehydratedQuery => {\n    var _options$defaultOptio2;\n\n    const query = queryCache.get(dehydratedQuery.queryHash); // Do not hydrate if an existing query exists with newer data\n\n    if (query) {\n      if (query.state.dataUpdatedAt < dehydratedQuery.state.dataUpdatedAt) {\n        query.setState(dehydratedQuery.state);\n      }\n\n      return;\n    } // Restore query\n\n\n    queryCache.build(client, { ...(options == null ? void 0 : (_options$defaultOptio2 = options.defaultOptions) == null ? void 0 : _options$defaultOptio2.queries),\n      queryKey: dehydratedQuery.queryKey,\n      queryHash: dehydratedQuery.queryHash\n    }, dehydratedQuery.state);\n  });\n}\n\nexport { CancelledError, InfiniteQueryObserver, MutationCache, MutationObserver, QueriesObserver, QueryCache, QueryClient, QueryObserver, dehydrate, focusManager, hashQueryKey, hydrate, isCancelledError, isError, notifyManager, onlineManager, parseFilterArgs, parseMutationArgs, parseMutationFilterArgs, parseQueryArgs };\n//# sourceMappingURL=index.js.map\n", "import * as React from 'react'\n\nimport { QueryClient } from '@tanstack/query-core'\nimport { ContextOptions } from './types'\n\ndeclare global {\n  interface Window {\n    ReactQueryClientContext?: React.Context<QueryClient | undefined>\n  }\n}\n\nexport const defaultContext = React.createContext<QueryClient | undefined>(\n  undefined,\n)\nconst QueryClientSharingContext = React.createContext<boolean>(false)\n\n// If we are given a context, we will use it.\n// Otherwise, if contextSharing is on, we share the first and at least one\n// instance of the context across the window\n// to ensure that if React Query is used across\n// different bundles or microfrontends they will\n// all use the same **instance** of context, regardless\n// of module scoping.\nfunction getQueryClientContext(\n  context: React.Context<QueryClient | undefined> | undefined,\n  contextSharing: boolean,\n) {\n  if (context) {\n    return context\n  }\n  if (contextSharing && typeof window !== 'undefined') {\n    if (!window.ReactQueryClientContext) {\n      window.ReactQueryClientContext = defaultContext\n    }\n\n    return window.ReactQueryClientContext\n  }\n\n  return defaultContext\n}\n\nexport const useQueryClient = ({ context }: ContextOptions = {}) => {\n  const queryClient = React.useContext(\n    getQueryClientContext(context, React.useContext(QueryClientSharingContext)),\n  )\n\n  if (!queryClient) {\n    throw new Error('No QueryClient set, use QueryClientProvider to set one')\n  }\n\n  return queryClient\n}\n\ntype QueryClientProviderPropsBase = {\n  client: QueryClient\n  children?: React.ReactNode\n}\ntype QueryClientProviderPropsWithContext = ContextOptions & {\n  contextSharing?: never\n} & QueryClientProviderPropsBase\ntype QueryClientProviderPropsWithContextSharing = {\n  context?: never\n  contextSharing?: boolean\n} & QueryClientProviderPropsBase\n\nexport type QueryClientProviderProps =\n  | QueryClientProviderPropsWithContext\n  | QueryClientProviderPropsWithContextSharing\n\nexport const QueryClientProvider = ({\n  client,\n  children,\n  context,\n  contextSharing = false,\n}: QueryClientProviderProps): JSX.Element => {\n  React.useEffect(() => {\n    client.mount()\n    return () => {\n      client.unmount()\n    }\n  }, [client])\n\n  const Context = getQueryClientContext(context, contextSharing)\n\n  return (\n    <QueryClientSharingContext.Provider value={!context && contextSharing}>\n      <Context.Provider value={client}>{children}</Context.Provider>\n    </QueryClientSharingContext.Provider>\n  )\n}\n", "import * as React from 'react'\n\nconst IsRestoringContext = React.createContext(false)\n\nexport const useIsRestoring = () => React.useContext(IsRestoringContext)\nexport const IsRestoringProvider = IsRestoringContext.Provider\n", "import * as React from 'react'\nimport { useSyncExternalStore } from 'use-sync-external-store/shim'\n\nimport {\n  QueryKey,\n  QueryFunction,\n  notifyManager,\n  QueriesObserver,\n} from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport { UseQueryOptions, UseQueryResult } from './types'\nimport { useIsRestoring } from './isRestoring'\n\n// This defines the `UseQueryOptions` that are accepted in `QueriesOptions` & `GetOptions`.\n// - `context` is omitted as it is passed as a root-level option to `useQueries` instead.\ntype UseQueryOptionsForUseQueries<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = Omit<UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>, 'context'>\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\ntype GetOptions<T> =\n  // Part 1: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n  T extends {\n    queryFnData: infer TQueryFnData\n    error?: infer TError\n    data: infer TData\n  }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? UseQueryOptionsForUseQueries<unknown, TError, TData>\n    : // Part 2: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n    T extends [infer TQueryFnData, infer TError, infer TData]\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends [infer TQueryFnData, infer TError]\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? UseQueryOptionsForUseQueries<TQueryFnData>\n    : // Part 3: responsible for inferring and enforcing type if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey>\n        select: (data: any) => infer TData\n      }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, unknown, TData, TQueryKey>\n    : T extends { queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey> }\n    ? UseQueryOptionsForUseQueries<\n        TQueryFnData,\n        unknown,\n        TQueryFnData,\n        TQueryKey\n      >\n    : // Fallback\n      UseQueryOptionsForUseQueries\n\ntype GetResults<T> =\n  // Part 1: responsible for mapping explicit type parameter to function result, if object\n  T extends { queryFnData: any; error?: infer TError; data: infer TData }\n    ? UseQueryResult<TData, TError>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? UseQueryResult<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? UseQueryResult<TData, TError>\n    : // Part 2: responsible for mapping explicit type parameter to function result, if tuple\n    T extends [any, infer TError, infer TData]\n    ? UseQueryResult<TData, TError>\n    : T extends [infer TQueryFnData, infer TError]\n    ? UseQueryResult<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? UseQueryResult<TQueryFnData>\n    : // Part 3: responsible for mapping inferred type to results, if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<unknown, any>\n        select: (data: any) => infer TData\n      }\n    ? UseQueryResult<TData>\n    : T extends { queryFn?: QueryFunction<infer TQueryFnData, any> }\n    ? UseQueryResult<TQueryFnData>\n    : // Fallback\n      UseQueryResult\n\n/**\n * QueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n */\nexport type QueriesOptions<\n  T extends any[],\n  Result extends any[] = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? UseQueryOptionsForUseQueries[]\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...Result, GetOptions<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? QueriesOptions<[...Tail], [...Result, GetOptions<Head>], [...Depth, 1]>\n  : unknown[] extends T\n  ? T\n  : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n  // use this to infer the param types in the case of Array.map() argument\n  T extends UseQueryOptionsForUseQueries<\n      infer TQueryFnData,\n      infer TError,\n      infer TData,\n      infer TQueryKey\n    >[]\n  ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData, TQueryKey>[]\n  : // Fallback\n    UseQueryOptionsForUseQueries[]\n\n/**\n * QueriesResults reducer recursively maps type param to results\n */\nexport type QueriesResults<\n  T extends any[],\n  Result extends any[] = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? UseQueryResult[]\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...Result, GetResults<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? QueriesResults<[...Tail], [...Result, GetResults<Head>], [...Depth, 1]>\n  : T extends UseQueryOptionsForUseQueries<\n      infer TQueryFnData,\n      infer TError,\n      infer TData,\n      any\n    >[]\n  ? // Dynamic-size (homogenous) UseQueryOptions array: map directly to array of results\n    UseQueryResult<unknown extends TData ? TQueryFnData : TData, TError>[]\n  : // Fallback\n    UseQueryResult[]\n\nexport function useQueries<T extends any[]>({\n  queries,\n  context,\n}: {\n  queries: readonly [...QueriesOptions<T>]\n  context?: UseQueryOptions['context']\n}): QueriesResults<T> {\n  const queryClient = useQueryClient({ context })\n  const isRestoring = useIsRestoring()\n\n  const defaultedQueries = React.useMemo(\n    () =>\n      queries.map((options) => {\n        const defaultedOptions = queryClient.defaultQueryOptions(options)\n\n        // Make sure the results are already in fetching state before subscribing or updating options\n        defaultedOptions._optimisticResults = isRestoring\n          ? 'isRestoring'\n          : 'optimistic'\n\n        return defaultedOptions\n      }),\n    [queries, queryClient, isRestoring],\n  )\n\n  const [observer] = React.useState(\n    () => new QueriesObserver(queryClient, defaultedQueries),\n  )\n\n  const result = observer.getOptimisticResult(defaultedQueries)\n\n  useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        isRestoring\n          ? () => undefined\n          : observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer, isRestoring],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setQueries(defaultedQueries, { listeners: false })\n  }, [defaultedQueries, observer])\n\n  return result as QueriesResults<T>\n}\n", "import * as React from 'react'\n\n// CONTEXT\n\ninterface QueryErrorResetBoundaryValue {\n  clearReset: () => void\n  isReset: () => boolean\n  reset: () => void\n}\n\nfunction createValue(): QueryErrorResetBoundaryValue {\n  let isReset = false\n  return {\n    clearReset: () => {\n      isReset = false\n    },\n    reset: () => {\n      isReset = true\n    },\n    isReset: () => {\n      return isReset\n    },\n  }\n}\n\nconst QueryErrorResetBoundaryContext = React.createContext(createValue())\n\n// HOOK\n\nexport const useQueryErrorResetBoundary = () =>\n  React.useContext(QueryErrorResetBoundaryContext)\n\n// COMPONENT\n\nexport interface QueryErrorResetBoundaryProps {\n  children:\n    | ((value: QueryErrorResetBoundaryValue) => React.ReactNode)\n    | React.ReactNode\n}\n\nexport const QueryErrorResetBoundary = ({\n  children,\n}: QueryErrorResetBoundaryProps) => {\n  const [value] = React.useState(() => createValue())\n  return (\n    <QueryErrorResetBoundaryContext.Provider value={value}>\n      {typeof children === 'function'\n        ? (children as Function)(value)\n        : children}\n    </QueryErrorResetBoundaryContext.Provider>\n  )\n}\n", "export function shouldThrowError<T extends (...args: any[]) => boolean>(\n  _useErrorBoundary: boolean | T | undefined,\n  params: Parameters<T>,\n): boolean {\n  // Allow useErrorBoundary function to override throwing behavior on a per-error basis\n  if (typeof _useErrorBoundary === 'function') {\n    return _useErrorBoundary(...params)\n  }\n\n  return !!_useErrorBoundary\n}\n", "import * as React from 'react'\nimport { useSyncExternalStore } from 'use-sync-external-store/shim'\n\nimport { QueryKey, notifyManager, QueryObserver } from '@tanstack/query-core'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport { useQueryClient } from './QueryClientProvider'\nimport { UseBaseQueryOptions } from './types'\nimport { shouldThrowError } from './utils'\nimport { useIsRestoring } from './isRestoring'\n\nexport function useBaseQuery<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: UseBaseQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  Observer: typeof QueryObserver,\n) {\n  const queryClient = useQueryClient({ context: options.context })\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n  const defaultedOptions = queryClient.defaultQueryOptions(options)\n\n  // Make sure results are optimistically set in fetching state before subscribing or updating options\n  defaultedOptions._optimisticResults = isRestoring\n    ? 'isRestoring'\n    : 'optimistic'\n\n  // Include callbacks in batch renders\n  if (defaultedOptions.onError) {\n    defaultedOptions.onError = notifyManager.batchCalls(\n      defaultedOptions.onError,\n    )\n  }\n\n  if (defaultedOptions.onSuccess) {\n    defaultedOptions.onSuccess = notifyManager.batchCalls(\n      defaultedOptions.onSuccess,\n    )\n  }\n\n  if (defaultedOptions.onSettled) {\n    defaultedOptions.onSettled = notifyManager.batchCalls(\n      defaultedOptions.onSettled,\n    )\n  }\n\n  if (defaultedOptions.suspense) {\n    // Always set stale time when using suspense to prevent\n    // fetching again when directly mounting after suspending\n    if (typeof defaultedOptions.staleTime !== 'number') {\n      defaultedOptions.staleTime = 1000\n    }\n  }\n\n  if (defaultedOptions.suspense || defaultedOptions.useErrorBoundary) {\n    // Prevent retrying failed query if the error boundary has not been reset yet\n    if (!errorResetBoundary.isReset()) {\n      defaultedOptions.retryOnMount = false\n    }\n  }\n\n  const [observer] = React.useState(\n    () =>\n      new Observer<TQueryFnData, TError, TData, TQueryData, TQueryKey>(\n        queryClient,\n        defaultedOptions,\n      ),\n  )\n\n  const result = observer.getOptimisticResult(defaultedOptions)\n\n  useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        isRestoring\n          ? () => undefined\n          : observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer, isRestoring],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    errorResetBoundary.clearReset()\n  }, [errorResetBoundary])\n\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setOptions(defaultedOptions, { listeners: false })\n  }, [defaultedOptions, observer])\n\n  // Handle suspense\n  if (\n    defaultedOptions.suspense &&\n    result.isLoading &&\n    result.isFetching &&\n    !isRestoring\n  ) {\n    throw observer\n      .fetchOptimistic(defaultedOptions)\n      .then(({ data }) => {\n        defaultedOptions.onSuccess?.(data as TData)\n        defaultedOptions.onSettled?.(data, null)\n      })\n      .catch((error) => {\n        errorResetBoundary.clearReset()\n        defaultedOptions.onError?.(error)\n        defaultedOptions.onSettled?.(undefined, error)\n      })\n  }\n\n  // Handle error boundary\n  if (\n    result.isError &&\n    !errorResetBoundary.isReset() &&\n    !result.isFetching &&\n    shouldThrowError(defaultedOptions.useErrorBoundary, [\n      result.error,\n      observer.getCurrentQuery(),\n    ])\n  ) {\n    throw result.error\n  }\n\n  // Handle result property usage tracking\n  return !defaultedOptions.notifyOnChangeProps\n    ? observer.trackResult(result)\n    : result\n}\n", "import {\n  parseQueryArgs,\n  QueryFunction,\n  QueryKey,\n  QueryObserver,\n} from '@tanstack/query-core'\nimport { DefinedUseQueryResult, UseQueryOptions, UseQueryResult } from './types'\nimport { useBaseQuery } from './useBaseQuery'\n\n// HOOK\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'initialData'\n  > & { initialData?: () => undefined },\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'initialData'\n  > & { initialData: TQueryFnData | (() => TQueryFnData) },\n): DefinedUseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'initialData'\n  > & { initialData?: () => undefined },\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'initialData'\n  > & { initialData: TQueryFnData | (() => TQueryFnData) },\n): DefinedUseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey'\n  >,\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn' | 'initialData'\n  > & { initialData?: () => undefined },\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn' | 'initialData'\n  > & { initialData: TQueryFnData | (() => TQueryFnData) },\n): DefinedUseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn'\n  >,\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData,\n  TError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  arg1: TQueryKey | UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  arg2?:\n    | QueryFunction<TQueryFnData, TQueryKey>\n    | UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  arg3?: UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UseQueryResult<TData, TError> {\n  const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n  return useBaseQuery(parsedOptions, QueryObserver)\n}\n", "import * as React from 'react'\n\nimport { hydrate, HydrateOptions } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport { ContextOptions } from './types'\n\nexport function useHydrate(\n  state: unknown,\n  options: HydrateOptions & ContextOptions = {},\n) {\n  const queryClient = useQueryClient({ context: options.context })\n\n  const optionsRef = React.useRef(options)\n  optionsRef.current = options\n\n  // Running hydrate again with the same queries is safe,\n  // it wont overwrite or initialize existing queries,\n  // relying on useMemo here is only a performance optimization.\n  // hydrate can and should be run *during* render here for SSR to work properly\n  React.useMemo(() => {\n    if (state) {\n      hydrate(queryClient, state, optionsRef.current)\n    }\n  }, [queryClient, state])\n}\n\nexport interface HydrateProps {\n  state?: unknown\n  options?: HydrateOptions\n  children?: React.ReactNode\n}\n\nexport const Hydrate = ({ children, options, state }: HydrateProps) => {\n  useHydrate(state, options)\n  return children as React.ReactElement\n}\n", "import * as React from 'react'\nimport {\n  QueryKey,\n  notifyManager,\n  parseFilterArgs,\n  QueryFilters,\n} from '@tanstack/query-core'\n\nimport { useSyncExternalStore } from 'use-sync-external-store/shim'\nimport { ContextOptions } from './types'\nimport { useQueryClient } from './QueryClientProvider'\n\ninterface Options extends ContextOptions {}\n\nexport function useIsFetching(filters?: QueryFilters, options?: Options): number\nexport function useIsFetching(\n  queryKey?: QueryKey,\n  filters?: QueryFilters,\n  options?: Options,\n): number\nexport function useIsFetching(\n  arg1?: QueryKey | QueryFilters,\n  arg2?: QueryFilters | Options,\n  arg3?: Options,\n): number {\n  const [filters, options = {}] = parseFilterArgs(arg1, arg2, arg3)\n  const queryClient = useQueryClient({ context: options.context })\n  const queryCache = queryClient.getQueryCache()\n\n  return useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        queryCache.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [queryCache],\n    ),\n    () => queryClient.isFetching(filters),\n    () => queryClient.isFetching(filters),\n  )\n}\n", "import * as React from 'react'\nimport { useSyncExternalStore } from 'use-sync-external-store/shim'\n\nimport {\n  notifyManager,\n  MutationKey,\n  MutationFilters,\n  parseMutationFilterArgs,\n} from '@tanstack/query-core'\nimport { ContextOptions } from './types'\nimport { useQueryClient } from './QueryClientProvider'\n\ninterface Options extends ContextOptions {}\n\nexport function useIsMutating(\n  filters?: MutationFilters,\n  options?: Options,\n): number\nexport function useIsMutating(\n  mutationKey?: MutationKey,\n  filters?: Omit<MutationFilters, 'mutationKey'>,\n  options?: Options,\n): number\nexport function useIsMutating(\n  arg1?: MutationKey | MutationFilters,\n  arg2?: Omit<MutationFilters, 'mutationKey'> | Options,\n  arg3?: Options,\n): number {\n  const [filters, options = {}] = parseMutationFilterArgs(arg1, arg2, arg3)\n\n  const queryClient = useQueryClient({ context: options.context })\n  const mutationCache = queryClient.getMutationCache()\n\n  return useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        mutationCache.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [mutationCache],\n    ),\n    () => queryClient.isMutating(filters),\n    () => queryClient.isMutating(filters),\n  )\n}\n", "import * as React from 'react'\nimport { useSyncExternalStore } from 'use-sync-external-store/shim'\n\nimport {\n  notifyManager,\n  parseMutationArgs,\n  MutationObserver,\n  MutationFunction,\n  MutationKey,\n} from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport {\n  UseMutateFunction,\n  UseMutationOptions,\n  UseMutationResult,\n} from './types'\nimport { shouldThrowError } from './utils'\n\n// HOOK\n\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  options: UseMutationOptions<TData, TError, TVariables, TContext>,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationFn: MutationFunction<TData, TVariables>,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationFn'\n  >,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationKey: MutationKey,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationKey'\n  >,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationKey: MutationKey,\n  mutationFn?: MutationFunction<TData, TVariables>,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationKey' | 'mutationFn'\n  >,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  arg1:\n    | MutationKey\n    | MutationFunction<TData, TVariables>\n    | UseMutationOptions<TData, TError, TVariables, TContext>,\n  arg2?:\n    | MutationFunction<TData, TVariables>\n    | UseMutationOptions<TData, TError, TVariables, TContext>,\n  arg3?: UseMutationOptions<TData, TError, TVariables, TContext>,\n): UseMutationResult<TData, TError, TVariables, TContext> {\n  const options = parseMutationArgs(arg1, arg2, arg3)\n  const queryClient = useQueryClient({ context: options.context })\n\n  const [observer] = React.useState(\n    () =>\n      new MutationObserver<TData, TError, TVariables, TContext>(\n        queryClient,\n        options,\n      ),\n  )\n\n  React.useEffect(() => {\n    observer.setOptions(options)\n  }, [observer, options])\n\n  const result = useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  const mutate = React.useCallback<\n    UseMutateFunction<TData, TError, TVariables, TContext>\n  >(\n    (variables, mutateOptions) => {\n      observer.mutate(variables, mutateOptions).catch(noop)\n    },\n    [observer],\n  )\n\n  if (\n    result.error &&\n    shouldThrowError(observer.options.useErrorBoundary, [result.error])\n  ) {\n    throw result.error\n  }\n\n  return { ...result, mutate, mutateAsync: result.mutate }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() {}\n", "import {\n  QueryObserver,\n  InfiniteQueryObserver,\n  QueryFunction,\n  QueryKey,\n  parseQueryArgs,\n} from '@tanstack/query-core'\nimport { UseInfiniteQueryOptions, UseInfiniteQueryResult } from './types'\nimport { useBaseQuery } from './useBaseQuery'\n\n// HOOK\n\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UseInfiniteQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryFnData,\n    TQueryKey\n  >,\n): UseInfiniteQueryResult<TData, TError>\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryFnData,\n      TQueryKey\n    >,\n    'queryKey'\n  >,\n): UseInfiniteQueryResult<TData, TError>\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: Omit<\n    UseInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryFnData,\n      TQueryKey\n    >,\n    'queryKey' | 'queryFn'\n  >,\n): UseInfiniteQueryResult<TData, TError>\nexport function useInfiniteQuery<\n  TQueryFnData,\n  TError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  arg1:\n    | TQueryKey\n    | UseInfiniteQueryOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryFnData,\n        TQueryKey\n      >,\n  arg2?:\n    | QueryFunction<TQueryFnData, TQueryKey>\n    | UseInfiniteQueryOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryFnData,\n        TQueryKey\n      >,\n  arg3?: UseInfiniteQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryFnData,\n    TQueryKey\n  >,\n): UseInfiniteQueryResult<TData, TError> {\n  const options = parseQueryArgs(arg1, arg2, arg3)\n  return useBaseQuery(\n    options,\n    InfiniteQueryObserver as typeof QueryObserver,\n  ) as UseInfiniteQueryResult<TData, TError>\n}\n"],
  "mappings": "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",
  "names": ["React", "useState", "useEffect", "useSyncExternalStore", "error", "noop", "promise", "defaultContext", "createContext", "undefined", "QueryClientSharingContext", "getQueryClientContext", "context", "contextSharing", "window", "ReactQueryClientContext", "useQueryClient", "queryClient", "useContext", "Error", "QueryClientProvider", "client", "children", "React", "useEffect", "mount", "unmount", "Context", "IsRestoringContext", "useIsRestoring", "IsRestoringProvider", "Provider", "useQueries", "queries", "isRestoring", "defaultedQueries", "useMemo", "map", "options", "defaultedOptions", "defaultQueryOptions", "_optimisticResults", "observer", "useState", "QueriesObserver", "result", "getOptimisticResult", "useSyncExternalStore", "useCallback", "onStoreChange", "subscribe", "notifyManager", "batchCalls", "getCurrentResult", "setQueries", "listeners", "createValue", "isReset", "clearReset", "reset", "QueryErrorResetBoundaryContext", "useQueryErrorResetBoundary", "QueryErrorResetBoundary", "value", "shouldThrowError", "_useErrorBoundary", "params", "useBaseQuery", "Observer", "errorResetBoundary", "onError", "onSuccess", "onSettled", "suspense", "staleTime", "useErrorBoundary", "retryOnMount", "setOptions", "isLoading", "isFetching", "fetchOptimistic", "then", "data", "catch", "error", "isError", "getCurrentQuery", "notifyOnChangeProps", "trackResult", "useQuery", "arg1", "arg2", "arg3", "parsedOptions", "parseQueryArgs", "QueryObserver", "useHydrate", "state", "optionsRef", "useRef", "current", "hydrate", "Hydrate", "useIsFetching", "filters", "parseFilterArgs", "queryCache", "getQueryCache", "useIsMutating", "parseMutationFilterArgs", "mutationCache", "getMutationCache", "isMutating", "useMutation", "parseMutationArgs", "MutationObserver", "mutate", "variables", "mutateOptions", "mutateAsync", "useInfiniteQuery", "InfiniteQueryObserver"]
}
